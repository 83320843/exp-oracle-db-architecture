# 知识扩展收集

##　涉及到的技术知识

　细粒度访问控制(find grained access control  FGAC)特性

## 常用英文收集

ASM:automatic storage management【自动存储管理】

SGA:system global area 【系统全局区】

PGA:process global area 【进程全局区】

UGA:user global area 【用户全局区】

server process:用户进程 

background process：后台进程

slave process ：从属进程

single tanent :单租户

multitanet：多租户

container/root database 容器数据库/根数据库

pluggable【ˈplʌgəbl】 database 可插拨数据库

real application clusters：真正应用数据库 RAC

instrumented[ˈɪnstrəməntɪd]：可测量，可感应的

automatic workload repository[rɪˈpɑːzətɔːri]：自动负载存储库【AWR】

active session history：活动会话历史【ASH】

automatic diagnostic [ˌdaɪəɡˈnɑːstɪk] repository：自动诊断存储库

SQL preformance analyzer[ˈænəˌlaɪzər]：SQL性能分析器

persimistic locking[ˌpesɪˈmɪstɪk]:悲观锁

optimistic locking)[ˌɑːptɪˈmɪstɪk]:乐观锁



# 第一章 开发成功的oracle应用

## 1.3.3 多版本控制

读一致性与多版本控制

```
SQL> variable scn number
SQL> exec :scn := dbms_flashback.get_system_change_number;
PL/SQL procedure successfully completed
scn
---------
2571961

SQL> select count(*) from emp;

  COUNT(*)
----------
        14

SQL> delete from emp;

14 rows deleted

SQL> commit;

Commit complete

SQL> select count(*), :scn then_scn,dbms_flashback.get_system_change_number now_scn from emp 
  2  as of scn :scn;

  COUNT(*)   THEN_SCN    NOW_SCN
---------- ---------- ----------
        14    2571961    2572014
scn
---------
2571961

SQL> alter table emp enable row movement;

Table altered

SQL> flashback table emp to scn :scn;

Done
scn
---------
2571961

SQL> select cnt_now,cnt_then,
  2  :scn then_scn, dbms_flashback.get_system_change_number now_scn from (select count(*) cnt_now from emp),
  3  (select count(*) cnt_then from emp as of scn :scn)
  4  /

   CNT_NOW   CNT_THEN   THEN_SCN    NOW_SCN
---------- ---------- ---------- ----------
        14         14    2571961    2572089
scn
---------
2571961
```

session级别控制同个账户同时只能登录一个

```
SQL> create profile one_session limit sessions_per_user 1;

Profile created

SQL> alter user scott profile one_session;

User altered

SQL> alter system set resource_limit=true;

System altered
```

# 第二章 体系结构概述

## 2.1定义数据库和实例

## 2.2 连接Oracle

## 2.3 可插拔式数据库

### 2.3.1 降低资源用量

### 2.3.2 降低维护开销

# 第三章 文件

oracle文件分为以下类型：

参数文件(parameter file)：告诉Oracle在哪可以找到控制文件，应当以某种内在结构设置多大空间等。

跟踪文件(trace file)：通常是服务器进程对某种异常错误条件作出的响应时创建的诊断文件。

警告文件（alert file)：与跟踪文件类似，但是包含“期望”事件的有关信息，并且通过一个集中式文件（其中包括多个数据库事件）警告DBA

数据文件（data file)：这些文件是数据库的主要文件，其中包括表、索引和所有其他的段。

临时文件（temp file)：这些文件用于完成基于磁盘的排序和临时数据的存储。

控制文件（control file)：这些文件能告诉你数据文件、临时文件和重做日志文件在哪里，还会指出与文件状态有关的其他元数据。RMAN也会在这个文件存放数据库备份的信息。

重做日志文件（redo log file)： 这些就是事务日志。

密码文件（password file)这些文件用于认证数据库的SYS角色用户。

从Oracle10G开始，添加两类新文件，可以帮助ORACLE实现更快的备份和恢复操作。

修改跟踪文件（change-tracking file):这个文件用于ORACLE数据库建立增量备份

闪回日志文件（flashback log file)： 这些文件存储数据库块的“前映像”，它用于新增加的flashback database命令。

还会讨论

转储文件（dump file ,DMP file)：由ORACLE提供的EXP（导出）工具生成，并由IMP（导入使用），exp已被当前版本弃用，imp命令还可以继续使用，用于将老版本数据导入到新版本的数据库中。

数据泵文件（Data Pump file)：由ORACLE数据泵expdp导出（Data PumpExport)进程生成，*并由数据泵mpdp导入（Data Pump  Import)进程使用。外部表也可以创建和使用这种文件格式。

平面文件（flat file)：这种无格式文件可以在文件编辑器中查处。通常会使用这些文件赂数据库中加载数据）



只要有数据文件和重做日志文件，就算其他文件都没有，也能得到数据。若把重做日志文件弄丢失了，但丢失一部分数据。



## 3.1 参数文件（init.ora 文件）

从Oracle 9i开始采用spfile(server parameter file) 

SID（site identifier):站点标识符

### 3.1.1 什么是参数

可通过V$parameter或者show parameters查看参数设置

需要设置参数文件init.ora时必须手工编辑该文件，而spfile文件时直接在数据库中修改就可以

### 3.1.2 init.ora参数文件（PFILE【parameter file】)

默认位置：

linux : $ORACLE_HOME/dbs

windows: %ORACLE_HOME%\DATABASE

若数据库是采用init.ora启动，则alter system改变参数之后并不会直接修改init.ora文件，需要手工编辑init.ora文件

init.ora可以放到客户端，即可以通过客户端加载init.ora启动数据库，但若服务器没有此文件，则会有麻烦

### 3.1.3 服务器参数文件(SPFILE[server parameter file])

杜绝了参数文件的繁殖

再也不能在数据库之外使用文本编辑器手动的维护参数文件

#### 1、从pfile转为为spfile

SQL>show parameter spfile【当value值是空时，表示是从pfile启动的数据库】

SQL>create spfile from pfile【创建spfile】

注意：在RAC中，所有实例共享一个spfile，因此从pfile转换到spfile需要更多的手动操作。spfile可以包含所有集群节点实例的参数设置，甚至是各个实例特有的设置，但转换之前我们需要将所有的节点的参数文件合并为一个有以下格式的pfile。

```
*.cluster_database_instance=2
*.cluster_database=TRUE
*cluster_interconnects='10.10.10.0'
*.compatiable='12.1.0.0.0'
*.control_files='/u1/d1/O12C/control01.ctl','/u1/d2/O12C/control02.ctl'
*.db_name='O12C'
...
*.processes=150
*.undo_management='AUTO'
O12C1.instance_number=1
O12C2.instanc_number=2
O12C1.local_listener='LISTENER_O12C1'
O12C2.local_listener='LISTENER_O12C2'
O12C1.remote_listener='LISTENER_O12C2'
O12C2.remote_listener='LISTENER_O12C1'
O12C1.thread=1
O12C2.thread=2
O12C1.undo_tablespace='UNDOTBS1'
O12C2.undo_tablespace='UNDOTBS2'

```

集群中所有实例共享的参数设置都为*.开头。单个实例特有的参数设置（如INSTANCE_NUMBER)都以实例名(Oracle SID)为前缀。

*.db_name='O12C' 表明使用这个SPFILE所有的实例会装载一个名为O12C的数据库；

O12C1.undo_tablespace='UNDOTBS1'表明，实例O12C1会使用名为UNDOTBS1的undo表空间。

#### 2 、 设置SPFILE中的参数值

当依据SPFILE启动并运算数据库时，只能通过alter system来修改参数值, spfile文件是个二件制文件，不能用文本编辑器编辑。

原先使用init.ora参数文件时，通过alter system命令设置后，若忘记更新init.ora参数文件，或者把init.ora参数文件丢失了，就会产生问题。使用SPFILE则不会,alter system语法为：

```
alter system set parameter=value <comment='text'><deferred><scope=memery|spfile|both><sid='sid|*'><container=current|all>
```

comment='text' 是一个与此参数设置相关的可选注释。这个注释会出现在v$PARAMETER视图的UPDATE_COMMET字段中。如果将这个注释写入SPFILE，那么将来重启数据库之后也会看到这个注释。

deferred指定系统修改是否只对以后的会话生效（对当前建立的会话无效，包括执行此修改的会话）。默认情况下，alter sys命令会立即生效 ，但有些参数不能“立即“生效。只有新建立的会话才能使用这些修改之后的参数。可以通过如下命令查看哪些参数必须要deferred。

```
SQL> select name from v$parameter where issys_modifiable='DEFERRED';
```

sid='sid|*'主要用于集群环境，默认值为sid="*",SID选项可为集群中的每个实例单独地指定参数。如果不使用RAC，一般不需要指定SID=

container=current|all适用于多租户架构的数据库。如果当前连接是根容器数据库，则alter system的container=all选项可以将参数修改传递到所有的可插拔式数据库中。默认情况下，容器数据库的参数修改仅应用于自身。另需要注意的是可插拔式数据库（非根容器数据库）的参数存储于自身的数据字典中，而非SPFILE。当我们将其移动到另外一个容器时，其自身的参数设置也会随之一并转移。

comment示例

```
SQL> alter system set pga_aggregate_target=512M comment='20200620';
System altered

SQL> select value,update_comment from v$parameter where name='pga_aggregate_target';

VALUE                                                                            UPDATE_COMMENT
-------------------------------------------------------------------------------- --------------------------------------------------------------------------------
536870912                                                                        20200620
```

#### 3、取消spfile设置

```
alter system reset parametr <scope=memory|spfile|both> sid='sid|*'
```

```
SQL> alter system set sort_area_size=65536 deferred;
SQL> show parameter sort_are;
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
sort_area_retained_size              integer     0
sort_area_size                       integer     65536

SQL> create pfile='test.ora' from spfile;【test.ora中可以看到有sort_area_size参数】

取消参数设置
SQL> alter system reset sort_area_size scope=spfile;
SQL> create pfile='test.ora' from spfile;【test.ora中没有sort_area_size参数了】
```

#### 4、从SPFILE创建PFILE

从spfile创建pfile有两种作用

4.1 创建一个“一次性”参数文件（有某些特殊的参数），用于启动数据库完成维护工作

4.2 维护修改历史，在注释中记录修改。

#### 5、修改被破坏的spfile

##### 5.1 linux下修复

若SPFILE文件损坏在linux下可以使用strings提取文件

````
$ strings $ORACLE_HOME/dbs/spfile$ORACLE_SID.ora
````

##### 5.2 windows下修复

用写字版打开，复制里面的内容粘贴到init<ORACLE_SID>.ora中，创建启用实例的PFILE。

万一SPFILE丢失了，还可以通过警告日志恢复参数文件的信息。

#### 6、可插拔式数据库

## 3.2 跟踪文件

跟踪（trace file）文件能提供调试信息

ORACLE可测量必主要表现在以下几个方面：

1,V$视图：大多V$视图包含“调试“信息。V$waitstat，v$session_event等

2,审计(audit)命令

3,资源管理器（DBMS_RESOURCE_MANAGER),这个特性允许对数据库所使用的资源（CPU，IO等）进行更精细的管理。

4，ORACLE“事件”（event),能让ORACLE生成所需的跟踪或诊断信息。

5，DBMS_TRACE：这是PL/SQL引擎中的一个工具，会全面地记录存储过程的调用树、产生的异常以及遇到的错误

6，数据库事件触发器：这些触发器（如ON SERVERERROR)允许你监控和记录觉得“意外”或非正常的情况。例如,你可以记录发生“临时空间用尽”错误时正在运行的SQL。

7、SQL_TRACE/DBMS_MONITOR:这个工具用于查看数据库执行的SQL语句、等待事件以有其他性能/行为相关的诊断信息。



10G添加了automatic workload repository[rɪˈpɑːzətɔːri]：自动负载存储库【AWR】，active session history：活动会话历史【ASH】

11G添加了automatic diagnostic [ˌdaɪəɡˈnɑːstɪk] repository：自动诊断存储库SQL preformance analyzer[ˈænəˌlaɪzər]：SQL性能分析器

12C添加了DDL日志以记录数据库中所有的DDL操作，还添加了调试日志，用于记录数据库中生产的一些异常状况。

### 3.2.1  计划内的、由用户请求所产生的跟踪文件

这类文件一般由DBMS_MONITOR来生成

#### 3.2.1.1跟踪文件位置

不论是使用DBMS_MONITOR、SQL_TRACE还是扩展的跟踪工具，ORACLE都会在数据库服务器主机的以下两个位置生成跟踪文件：

专用服务器连接，会在user_dump_dest参数指定的目录中生成跟踪文件

共享服务器连接，会在background_dump_dest参数指定的目录中生成跟踪文件

有以下几种方式查看跟踪文件位置：

```
方法一：
SQL> show parameter dump_dest
方法二：
SQL> select name,value from v$parameter where name like '%dump_dest%';
方法三：

```

 查看各种跟踪文件的位置

```
select * from v$diag_info;
```

查看ADR详细信息

```
with home
  as
  (select value home
     from v$diag_info
    where name = 'ADR Home'
  )
  select name,
         case when value <> home.home
                  then replace(value,home.home,'$home$')
                          else value
              end value
    from v$diag_info, home
/

NAME                                                             VALUE
---------------------------------------------------------------- --------------------------------------------------------------------------------
Diag Enabled                                                     TRUE
ADR Base                                                         /u01/app/oracle
ADR Home                                                         /u01/app/oracle/diag/rdbms/pos/POS
Diag Trace                                                       $home$/trace
Diag Alert                                                       $home$/alert
Diag Incident                                                    $home$/incident
Diag Cdump                                                       $home$/cdump
Health Monitor                                                   $home$/hm
Default Trace File                                               $home$/trace/POS_ora_19454.trc
Active Problem Count                                             1
Active Incident Count                                            11
ORACLE_HOME                                                      /u01/app/oracle/product/19.3.0/db_1
12 rows selected
```

Diag Trace(诊断跟踪文件)：这是11g及以下版本的跟踪文件所在位置（包括后台和用户转储目标）

Default TraceFile(默认跟踪文件)：这是当前会话的跟踪文件名。

Oracle 11g之前:共享模式的跟踪文件位于background_dump_dest,专用模式跟踪文件位于user_dump_dest

#### 3.2.1.2 命名约定

```
Default Trace File                                 $home$/trace/POS_ora_19454.trc
```

文件名第一部分为$ORACLE_SID

第二部分为ora

第三部分为专用服务器上的操作系统的进程ID，可以通过v$process视图获得

11g及之后的可以直接通过v$diag_info获得诊断位置信息，11g之前的需要通过通过视图才能获得

v$parameter：找到user_dump_dest指定的跟踪文件位置，叵初始化参数中设置了tracefile_identifier那么此参数的值也为跟踪文件名的一部分

v$process：查找操作系统上的进程ID

v$session：正确地标识其他视图中的会话信息（v$process来定位当前会话的进程ID）

v$instance：获得ORACLE_SID

```
column trace new_val TRACE format a100
select c.value || '/' || d.instance_name || '_ora_' || a.spid || '.trc' trace
    from v$process a, v$session b, v$parameter c, v$instance d
   where a.addr = b.paddr
     and b.audsid = userenv('sessionid')
     and c.name = 'user_dump_dest'
/
```

####  3.2.1.3 对跟踪文件加标记

```

SQL> alter session set tracefile_identifier='Look_for_me';
SQL> exec dbms_monitor.session_trace_enable;
$ ll *me*
-rw-r-----. 1 oracle dba 2095 Jun 21 18:15 POS_ora_23851_Look_for_me.trc
-rw-r-----. 1 oracle dba 1122 Jun 21 18:15 POS_ora_23851_Look_for_me.trm
```

### 3.2.2 针对内部错误生成的跟踪文件

执行时报的ORA-00600或另外某个内部错误而自动生成的，这种错误是用于oracle support来查看的

## 3.3 警告文件【警告日志】

警告日志是一个简单的文本文件，数据库从“出生”（创建）那一天开始就会不停写该文件，直到库“完结”（被删除）为止。在这个文件中，可以看到数据库的“编年史”，比如说在线日志文件切换，内部错误，表空间的创建，离线以及恢复为在线等等。

## 3.4 数据文件

### 3.4.1 简要回顾文件系统机制

1、格式化好的(cooked）操作系统（OS）：数据库文件就像文字处理文档一样放在文件系统中。Cooded OS文件一直是Oracle中存储数据的“最流行”的方法。随着着ASM引入，此种情况会有所改观。数据库服务器中，格式化好的文件系统通常也会缓存数据，也就是说在数据库读写磁盘时，OS会为你缓存一些信息。

2、裸分区(raw partition)：这不是文件，而是裸磁盘，不能用ls等命令查看，它们就是磁盘上的一些大扇区，没有任何文件系统。只有极少数Oracle数据库使用裸分区，裸分区管理开销大，裸分区没有缓冲，所有IO都是对存储设备直接操作，没有任何OS缓冲（对于数据库来说，这通常也是一个优点）。【Oracle11g已弃用裸分区，在12c中不再提供支持】

3、自动存储管理（automatic storage management,ASM):10g R1的新特性，ASM仅供数据库使用的文件系统，只能存储与数据库相关的信息：表，索引、备份、控制文件、参数文件、重做日志以及归档文件等。

4、集群文件系统：RAC需要使用这种文件系统，为集群中的所有节点提供一个共享文件系统。11g R2开始提供自动存储管理集群文件系统（ACFS)，此集群文件系统让cooked文件系统优点延伸到集群环境中。

​    Oracle允许数据库组成的文件可以使用上述文件中任意组合

### 3.4.2 Oracle数据库中的存储层次体系 

数据库由一个或多个表空间构成。表空间是oracle中的一个逻辑存储容器，位于存储层次体系的顶层，包括一个或多个数据文件。

#### 3.4.2.1、段

段是表空间中主要的组织结构。段就是占用存储空间的数据库对象，如表、索引及回滚段等。创建表是会创建表段，创建分区表时，为每个分区创建一个段；创建索引时，会创建一个索引段，依此类推。还存在回滚段，临时段以有聚 簇段（cluster segment等)

```
“占用存储空间的每一个对象最后都会存储在一个段中”，指一条create语句最后创建的对象可能包含0个、1个或多个段。例如：create table T(x int primary key,y clob)就会创建4个段：一个表段，一个索引段，另外还有两个clob段（一个clob段是lob索引，另一个是lob数据本身）
```

#### 3.4.2.2、区段（extent)

段本身又由一个或多个区段组成。区段是文件中一个逻辑上连续分配的空间。传统的每个段都至少有一个区段，自11g R2起oracle引入了" 延迟"段概念---当创建对象时，oracle不会立即为段分配一个区段只有当数据真正写入时，才分配。

#### 3.4.2.3、块

区段又进一步由块组成。块(block)是oracle最小的空间分配单位。通过oracle从磁盘读写的就是块。常用数据库大小有4种：2K,4K,8K,16K，也可以有非2的幂次方大小，但可能会遇到其他用户从未遇到的问题。

数据库中最多可以有6种不同的块大小：主要是用于衧一个名为“传输表空间”的功能。DBA可以利用这个功能来从一个数据库移动或复制到已经格式化好的数据库文件，把它放到另一个数据库中。

数据库还有一个默认的块大小，即执行create database 命令时初始化文件中指定的大小。system表空间总是使用这个默认块大小。

#### 3.4.2.4、表空间

表空间是一个容器，其中包含的段，每个段都只属于一个表空间。一个表空间可能有多个段，一个段的所有区段都在段所属的表空间中。段绝对不会跨越表空间边界。表空间本身可以有一个或多个 数据文件。一个区段仅会存放于一个数据文件中。不过，段可以有来自多个不同数据文件的区段。

#### 3.4.2.5 存储层次体系小结

Oracle中存储层次体系如下：

1，数据库由一个或多个表空间组成

2，表空间由一个或多个数据文件组成。这些文件可以是文件系统中的文件、裸分区，ASM管理的数据库文件，或集群文件系统上的文件。表空间包含段

3，段由一个或多个区段组成。段不能跨表空间存放，但是段中的数据可以跨文件（当然，隶属于同一个表空间）存放

4，区段是磁盘上一组逻辑连接的块。区段只能在一个表空间中，且总是在该表空间内的一个文件中

5，块是数据库中最小的分配单位，也是数据库使用的最小I/O单位

### 3.4.3 字典管理和本地管理的表空间

表空间如何管理区段：

Oracle8.1.5之前，表空间中管理区段的唯一方式是通过数据字典，相应这种表空间叫字典管理的表空间（dictionary-managed tablespace)。在此管理模式下，所有的空间管理维护操作都是在数据字典表中。数据字典更新只能是串行的，它不能并发的处理。

从8.1.5及后以的版本中，引入了本地管理表空间（locally-managed tablespace)。本地管理表空间会在每个数据文件中使用一个位图来管理区段，如果要得到一个区段，系统所做的只是在位图中将某一位设置为1；要释放一些空间，系统再把这一位设置为0.

```
如果数据库中的system是本地管理表空间，不是说这样的数据库不支持字典管理表空间，而是说我们无法在这个数据库中新建字典管理表空间。因为“可传输表空间”可将一个字典表空间的表空间“传输”到这个数据库
```

## 3.5 临时文件

​         oracle中的临时数据文件（temporary data file 或称临时文件 temp file)是一种特殊类型的数据文件。当内在不足时，oracle会使用它来储存一些临时数据，比如说一些比较大的排序或散列操作的中间结果，临时表中的数据库以及结果集数据等。自12c起，对临时表的操作所产生的undo也会放到临时表空间中，而在以前版本中，这部分undo是放在undo表空间中，因而会联动产生redo。永久性的表和索引永远不会存储在临时表空间中，但是临时表中的数据及其会存放在这里。

```
自oracle 12C起，全局临时表所产生的undo可以存放在临时表空间中。默认情况下，undo数据会像以前的版本一样放在undo表空间中。12c引入了一个参数temp_undo_enabled（全局/会话级别可设置），当这个参数设置为true时，全局临时表产生的undo会写入到临时表空间中。这样，对临时表所进行的操作集修改就不会再产生redo日志了。
```

注意linux下有稀疏

```
步骤一：创建一个临时表空间指定，大小为2G，通过df查看时，磁盘占用空间没有变动，但通过ls查看时，显示文件有2个G【未实际占用空间】
SQL> !df -h /tmp
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   50G   21G   30G  41% /
SQL> create temporary tablespace temp_huge tempfile '/tmp/temp_huge.dbf' size 2g;  
Tablespace created.
SQL> !df -h /tmp
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   50G   21G   30G  41% /
SQL> !ls -l /tmp/temp_huge.dbf
-rw-r-----. 1 oracle dba 2147491840 Jun 23 14:00 /tmp/temp_huge.dbf

步骤二：通过CP使用 --sparse=never禁止产生 sparse 文件进行复制数据文件，再删除原来的表空间及对应数据文件，最后指定非稀疏文件temp_huge_not_sparse.dbf为临时表空间文件，通过df命令查看，此文件已占用linux磁盘空间
SQL> !cp --sparse=never /tmp/temp_huge.dbf /tmp/temp_huge_not_sparse.dbf
SQL> drop tablespace temp_huge including contents and datafiles;
Tablespace dropped.
SQL> create temporary tablespace temp_huge tempfile '/tmp/temp_huge_not_sparse.dbf' reuse;
Tablespace created.
SQL> !df -h /tmp
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root   50G   23G   28G  45% /

```

## 3.6 控制文件

数据库启动时，实例会从参数文件中知道控制文件的位置，而通过控制文件则会知道数据库的数据文件和在线重做日志文件的位置。

​        控制文件还记录了数据库的其他一些信息，如检查点的有关信息，数据库名，数据库创建的时间戳，归档重做日志的大历史，以及RMAN信息。

​        此文件需要多路保存，丢失控制文件并不是致命的，但会使恢复变得困难很多。



## 3.7 重做日志文件

重做日志文件(redo log file)对于oracel数据库至关重要，它是数据库的事务日志。通常情况下重做日志用于恢复，但也可以用于：

1，系统崩溃后的实例恢复；

2，从备份复原出来的数据文件的介质恢复；

3，备用数据库处理；

4，Streams和Golden gate，这两个工具可以对重做日志进行挖掘，从而实现 信息共享（说白了就是复制）；

5，让管理员能够通过logminer功能查看数据库的历史事务

在oracle中完成的几乎所有操作都会生成redo，并写入到在线重做日志文件中。

若在数据库中启用了补充日志（supplemental logging)，drop table语句也会写入到重做日志中。

### 3.7.1 在线重做日志

每个oracle数据库至少有两个在线重做日志文件组，每个重做日志组都包含一个或多个重做日志成员（redo按成员组来管理)，同一个组内的重做日志文件是完全一样的镜像。这些在线重做日志文件的大小是固定的，并以循环方式使用。

```
举例：
oracle先写日志文件组1，当这组文件写满之后，会切换至日志文件组2，它会覆盖原来的内容；当日志文件组2填满时，oracel会再切换回日志文件组1
```



在设置在线重做日志大小和数目时，还有下列方面需要考虑：

1，高峰负载(peak workload):若在业务高峰期的时候不希望发生检查点的等待事件，你的重做日志的大小不应该以支撑“平均”的每小时业务吞吐量为目标，而应当以业务高峰吞吐量为基准

2，大量用户修改相同的块：大量用户都要修改相同的块

3，平均恢复时间：如果必须确保实例恢复要尽快地完成，即便是大量用户修改相同的块，我们也可能倾向于使用较小的重做日志文件。

### 3.7.2 归档重做日志

oracle可以采用两种模式运行：归档(archivelog)和非归档(noarchivelog)

## 3.8 密码文件

一般对*sysdba*的管理有两种方式：操作系统认证和密码文件认证

密码文件不是数据库运行时必须要有的文件，它用于远程sysdba或管理员访问数据库





使用PASSWORD文件认证方式的配置过程

设置scott用户可以用sysdba用户远程启动数据库【需要以静态注册方式运行数据库】：

```
SQL> show parameter remote_login_passwordfile;【使用EXCLUSIVE表示只有当前INSTANCE使用这个password文件。而且允许有别的用户作为sysdba登录进系统里边，而若选择了SHARED，则表明不止一个实例使用这个密码文件，伴随着一个很强的约束：sysdba权限只能授予sys和internal这两个用户名】
NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
remote_login_passwordfile	     string		    EXCLUSIVE

$orapwd file=orapw$ORACLE_SID password=sys entries=3;【Entries表示最大允许有的超级用户数目。这个是一个可选的，前两者是必须指定的。一般会把它设置的比实际需要大一些，以免不够】
执行完之后在$ORACE_HOME/dbs【linux】下会产生一个加密密码文件，在windows下会是在$ORACLE_HOME/database目录中

SQL> GRANT SYSDBA TO SCOTT;【这样SCOTT用户就具有了sysdba权限。注意，此时SCOTT用户可以以两种身份登录：SCOTT , SYS.当SCOTT在登录时没有输入AS SYSDBA时，SCOTT是作为普通用户登录的。而当登录时输入了AS SYSDBA时，此时SCOTT登录进去的用户实际上为sys】

SQL> select * from V$PWFILE_USERS 【查看有哪些用户具有sysdba权限】
```

## 3.9 修改跟踪文件（change-tracking file)

此文件不属于数据库运行时必须要有的文件，是10g之后新增加的一种文件，会记录自上一次增量备份以来哪些数据块被修改了，RMAN会依据此文件备份那些有变化的块，而不必读取整个数据库。

```
SQL> alter database enable block change tracking using file '/u01/app/oracle/diag/rdbms/pos/POS/trace/changed_blocks.bct';
Database altered.

SQL> alter database disable block change tracking;【linux下执行此命令之后，之前指定的文件会一并删除，而windows则不会】
Database altered.
```

## 3.10 闪回日志

是10g为支持flashback database而引入的，也是10g的一个新特性。闪回日志包括数据“被修改之前的映像”，它可用于将数据库返回（恢复）到之前某个时间点的状态。

### 3.10.1 闪回数据库

在引入flashbackup database功能之前，若需要恢复误删除某个用户的数据，只能按照下面的步骤做：

```
1，DBA要关闭数据库

2，DBA一般要从磁盘机复原(restore)最后的一个完整的数据库备份，通常比较耗时。通常得使用rman命令：restore database until<某个时间点>。

3，如果归档日志不是放在数据库服务器上，那么DBA可能还要复原最近的一个备份之后所生成的全部归档重做日志

4，接下来DBA要前滚数据库，这个过程通常要对复原出来的备份应用归档以及在线重做日志，并要在drop user这个动作之前停止应用。第3，4步一般使用RMAN命令：recover database until<某个时间点>

5，要以resetlogs方式打开数据库。

需要进行时间点恢复的原因很多，如升级脚本错误，升级失败，有权限的某个人无意地发出了某个命令等。
```

10g企业版后【此特性需要在归档模式下运行，且进行了相应的配置】

```
1,DBA关闭数据库
2，DBA启动并装载(mount)数据库，接下来使用flashback database命令，命令中指定时间点为SCN、复原点或者时间戳，这些时间点应当精确到秒
3，DBA以resetlogs选项打开数据库
```

###　3.10.2快速恢复区

fast recover area是10g及更高版本中的一个新逻辑概念。

Oracle使用快速恢复区来管理与数据库备份和恢复相关的文件。在这块区域中，你可以找到：

RMAN的备份片（全量或增量备份）；

Rman所做的镜像备份(数据文件及控制文件的镜像备份)；

在线重做日志；

归档重做日志；

多路的（multiplexed)控制文件；

闪回日志。

属于一个可选配置，没有必要非得使用，但若要使用诸如闪回数据库之类的高级特性，就必须用快速恢复区。



## 3.11 DMP文件（exp/imp文件）

DMP文件是平台独立的，但需要注意在windows平台使用FTP传输时，windows会默认地把DMP文件当成是一个“文本”文件，并把换行符转换为回车/换行对，会破坏DMP文件。故需要确保使用FTP时，采用二进制模式进行传输。



## 3.12 数据泵文件

有两个工具使用数据泵(data pump)文件格式：外部 表（external table)可以加载和制裁数据泵格式的数据，新的导入/导出工具impdp和expdp。与exp和imp类似

外部表(external table)最早在9i中引入。利用外部表，能像读取数据库表一样读取平面文件（无格式的文本文件），这样一来我们就能充分利用SQL的强大功能处理平面文件中的数据。外表表是只读的，其设计初衷为由数据库外部向oracle提供数据。10g R1及以上版本中的外部表还可以反着用：我们可以把数据以数据泵的格式卸载出来，然后将其转移到另外一个数据库上以便读取。要开始这个操作，我们首先需要创建一个direcory对象，告诉oracle制裁的位置。

```
可以通过导出二进制文件在不同的平台下的同一种数据库类型中进行数据查询【由低版本导出二进制文件，由高版本加载二进制文件没有问题，反之可能报错】
在11g中执行如下语句
SQL> create or replace directory tmp as 'D:\BackupPOS';
SQL> create table all_objects_unload
  2   organization external
  3  (type oracle_datapump
  4  default directory TMP
  5  location('allobjects.dat')
  6   )
  7  as select * from all_objects
  8  /
将文件allobjects.dat复制到19c下/tmp目录中  
 
在19c中用eoda用户登录执行如下语句:
SQL>create or replace directory tmp as '/tmp';
create table t
( OWNER            VARCHAR2(30),
  OBJECT_NAME      VARCHAR2(30),
  SUBOBJECT_NAME   VARCHAR2(30),
  OBJECT_ID        NUMBER,
  DATA_OBJECT_ID   NUMBER,
  OBJECT_TYPE      VARCHAR2 (19),
  CREATED          DATE ,
  LAST_DDL_TIME    DATE,
  TIMESTAMP        VARCHAR2(19),
  STATUS           VARCHAR2(7),
  TEMPORARY        VARCHAR2(1),
  GENERATED        VARCHAR2(1),
  SECONDARY        VARCHAR2(1)
)
organization external
( type oracle_datapump
  default directory TMP
  location( 'allobjects.dat' )
);
在19c中再执行select * from t即可看到原来的由11g导入的数据了
```

## 3.13 平面文件

​     平面文件是去除了所有特定应用（程序）格式的电子记录，从而使数据元素可以迁移到其他的应用上进行处理。这种去除电子数据格式的方式可以避免因为硬件和专用软件的过时而导致的数据丢失。

​      实际上，平面文件就是一个每一“行”都是一条“记录”的简单文件，在每行之间都有一些定界的符号，通常用逗号或管道符号分隔。通过使用数据加载工具如SQLLDR或外部表，Oracle可以很容易地读取平面文件。

​       不过,Oracle生成平面文件可就不那么容易



# 第四章 内存结构



主要讨论三个主要内存结构

1，系统全局区（SGA），这是一个大的共享内存段，几乎所有Oracle进程都要访问这个区域

2，进程全局区（PGA）：这是一个进程或线程专用的内存，其他进程/线程不能访问

3，用户全局区（UGA）：这个内存区与特定的会话相关联。它可能在SGA中分配，也可能在PGA中分配，这取决于是共享服务器还是专用服务器来连接数据库，如果是共享服务器，UGA就在SGA中分；如果是专用服务器，UGA就会在PGA中分配

ORACLE内存管理时，共有以下五种设置方法：

1，自动内存管理(automatic memory management,AMM),它是针对SGA和PGA的管理，并且只能应用在11g或更高的版本，此种模式下DBA只需要设置一个参数memory_target来指定数据库使用的内存目标，数据库将自行判断每个内存区域的大小。

```
SQL> show parameter memory_target

NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
memory_target			     big integer	    1152M
```

2,自动SGA内存管理(automatic shared memory management,ASMM)，它是针对SGA的管理，这种模式下DBA通过设置参数sga_target来指定整个SGA的目标大小。

```
SQL> show parameter sga_target;

NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
sga_target			     big integer	    0
```

3,手动SGA内存管理（manual shared memory management),它也是针对SGA的，DBA可以手动设置db_cache_size,shared_pool_size等参数来调整SGA中的每个区域的大小

4，自动PGA内存管理（automatic PGA memory managemet,它是针对PGA的，DBA可以通过设置参数pga_aggregate_target来指定整个PGA的目标大小

5，手动PGA内存管理（manual PGAmemory management)，它是针对PGA的，DBA可以手动设置sort_area_size,hash_area_size等参数调整PGA中每个区域的大小。Oracel强烈建议不要使用该方法。

## 4.1 进程全局区和用户全局区

​       PGA(进程全局区)是特定于进程的一段内存。换句话说，它是操作系统中某个进程或线程专用的内存，不允许系统中的其他进程或线程访问。PGA中的P代表process，是不共享的。

​       UGA（用户全局区）实际上来说，就是你的会话的状态。它是一段你的会话一直能访问到的内存。

​       PGA包含进程内存，还可能包含UGA。PGA内存中的其他区域通常用于完成内存中的排序，位置合并以及散列。可以肯定地说，除了UGA，这些区域在PGA中占的比重最大。

从9i R1起，有两种办法来管理PGA中的这些非UGA内存

* 手动PGA内存管理（manual PGA
  memory management)采用这种方法时，你要告诉oracel数据库，如果一个进程中需要排序或散列，允许使用多少内存来完成这些排序或散列

* 自动PGA内存管理（automatic PGA memory management),这要求你告诉数据库，PGA在系统范围内可以尝试使用多少内存。

从11gR1开始，自动PGA内存管理可以使用以下两种技术实现。

* 通过设置pga_aggregate_target初始化参数，告诉数据库在实例范围内PGA可以尝试使用多少内存。
* 通过设置memory_target初始化参数，告诉数据库实例应当允许SGA和PGA总共使用多少内存。数据库自己将根据这个参数确定合适的PGA大小。

PGA内存管理方法受数据库初始化参数workarea_size_policy的控制，可在会话级别进行修改。

### 4.1.1 手动PGA内存管理

以下参数对PGA大小的影响最大

* sort_area_size:在排序信息被交换到磁盘之前，所使用的内存总量（磁盘是指用户指定的磁盘上的临时表空间）
* sort_area_retained_size:排序完成后用于保存已排序数据的内存总量。也就是说，如果sort_area_size是512KB且sort_area_retained_size是256K，那服务器进程最初处理查询会用512k的内存对数据库排序。等排序完成时，排序区会“收缩”为256K，这256K内存中放不下的已排序数据会写出到临时表空间中。
* hash_area_size:服务器进程在内存中存储散列表所用的内存量在做一个大数据集与另一个数据集的连接时，会进行散列连接并使用这部分内存。两个数据集中较小的一个会被散列到内存中，内存中散列区中放不下的部分会通过连接键(join key)存储在临时表空间中。

例子略：

在使用*_area_size参数时，需要注意重要的几点：

* 这些参数控制着一个排序，散列或位图合并操作所用的最大内存量
* 一个查询可能包含多个操作，这些操作可能都要使用这部分内部，并且会创建多个排序/散列区。同时还要记住，你也可以同时打开多个游标，每个游标都有自己的sort_area_retained需求。所以，如果把排序区大小设置为10M，在会话中实际上可能会用到10M,100M,1000M或更多内存。设置这些参数并非是对整个会话的限制，它们只是对会话中的一个操作进行限制。而在你的会话中，一个查询可以有多个排序，或者多个查询需要用到一个排序。
* 这些内存区都是根据需要来分配的。如果像我们之前做的一样，将排序区大小设置为1G，这并不是说你实际分配了1G的内存给排序区，而是说，你允许oracle进程为一个排序/散列操作最多分配1G内存。

### 4.1.2 自动PGA内存管理

自动PGA内存管理，首先简单的建立SGA并确定其大小。SGA是一段大小固定的内存，可以看到它的准确大小，这也将是SGA的总大小（除非你做了调整）。确定了SGA的大小后，再告诉数据库PGA的大小。

打开自动PGA管理方法：

workarea_size_policy:这个参数可以设置为manual或auto。如果manual，会使用排序区和散列区大小参数来控制分配的内存量；如果是auto，分配的内存量会在PGA内存中自动地变化。默认值为auto，也是推荐设置

PGA_aggregate_target：这个参数会控制在数据库实例上为所有工作区（即所有排序区和散列区）分配的内存总量。在不同的数据库版本中，这个参数的默认值有所不同。若使用自动PGA内存管理，应该明确地设置这个参数。

​      假设workarea_size_policy设置为 auto ,pga_aggregate_taget设置为一个非0值，这时就是在使用自动PGA内存管理 了。可在会话级(alter session)别或者系统级别(alter system)打开自动PGA内存管理

* pga_aggregate_target是一个上限目标，而不是启动数库时预分配的内存大小。
* 某个具体的会话所能使用的pga内存量也依赖于pga_aggregate_target的设置
* 随着服务器上工作负载的增加（可能有越来越多的并发查询和并发用户），分配给各个工作区的PGA内存量会减少。

演示示例略

### 4.1.3 如何选择手动和自动内存管理

对于一直在数据库上运行的应用的最终用户，倾向于使用自动PGA内存管理。对于一些特定的空闲时间段执行大型批处理作业的情况，手动PGA内存管理会是一个合理的选择。

### 4.1.4 PGA和UGA小结

PGA是进程专用的内存区。这是oracle专用或共享服务器需要的一组不依赖于会话的变更。PGA是内存“堆”，其中还可以分配其他结构。UGA也是一个内存堆，其中定义了属于会话的结构。如果使用专用服务器连接数据库，UGA会从PGA中分配；如果使用共享服务器连接，UGA则从SGA中分配。这表明，使用共享服务器时，必须适当地设置SGA中大池（large pool)的大小，以便有足够的内存空间来应对每一个数据库并发用户。所以，相比于使用专用服务器连接方式，如果使用类似配置的共享服务器连接方式，需要设置更大的SGA。

## 4.2 系统全局区

V$查询视图

```
select * from v$sgastat;
select * from v$sgainfo;
select * from  v$sga;
SQL> show parameter sga;
```

使用linux命令查看ora的共享内存【默认会列出共享内存、信号量，队列信息，-m列出共享内存，-s列出共享信号量，-q列出共享队列
清除命令是ipcrm [-m|-s|-q] id。-m 删除共享内存，-s删除共享信号量，-q删除共享队列。】

```
$ ipcs -m|grep ora
```

在10g及以下版本中只需要设置sga_target参数，则启用了自动sga管理

示例：通过修改sga_target大小，查看颗粒变化情况

查看sga_target大小

```
修改pfile文件中sga_target大小，并且通过pfile启动数据库
SQL> startup pfile='/u01/app/oracle/product/19.3.0/db_1/dbs/initPOS.ora'
SQL> show parameter sga_target;

NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
sga_target			     big integer	    256M

SQL> create spfile from pfile;
SQL> startup force【abort关闭并且重启数据库】
SQL>  select component,granule_size from v$sga_dynamic_components;【颗粒大小为4M】

COMPONENT															 GRANULE_SIZE
-------------------------------------------------------------------------------------------------------------------------------- ------------
shared pool															      4194304
large pool															      4194304
java pool															      4194304

SQL> alter system set sga_target=1512m scope=spfile;

System altered.

SQL> startup force;
SQL> select component,granule_size from v$sga_dynamic_components;【颗粒大小变成了16M】

COMPONENT															 GRANULE_SIZE
-------------------------------------------------------------------------------------------------------------------------------- ------------
shared pool															     16777216
large pool															     16777216
```

### 4.2.1 固定SGA区

固定sga区（fixed SGA）是SGA的一组件，大小因平台和版本而异，我们无法控制其大小，不过通常都很小，可以把它理解为SGA的“启动”区(bootstrap)



### 4.2.2 重做缓冲区

数据需要写到在线重做日志时，在它们被写至磁盘前，需要在重做缓冲区（redo buffer)中临时缓存这些数据。LGWR进程在以下情况会把缓冲区数据刷新后台磁盘。

* 每3秒一次
* 发生提交(commit)或回滚（rollback)请求时
* 要求LGWR切换日志时
* 重做缓冲区用满1/3，或者缓存重做日志数据达到1M时。

默认log_buffer最小时，可通过将log_buffer设置为1字节，再重启数据库。再执行log_bufferr查看到的值即为了小值。

37199872[ERP-DB]

```
SQL> show parameter log_buffer;

NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
log_buffer			     big integer	    7360K
SQL> alter system set log_buffer=1 scope=spfile;

System altered.
SQL> show parameter log_buffer;

NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
log_buffer			     big integer	    840K
```

注意：默认log_buffer参数设置对于大部分数数据库应用都已足够，如果看到大量的log_buffer space相关的等待事件时，可以把log_buffer参数增大一些

### 4.2.3 块缓冲区缓存

块缓冲区缓存（block buffer cache):oracle将数据库块写至磁盘之前，或从磁盘上读取数据块之后，就会把这些数据库块存储在块缓冲区缓存中。

​      人oracle较早版本中，只有一个块缓冲区缓存，从任何段（segment)上读来的块都放到这个区中。从oracle8.0开始，可以把各个段上的已缓存块放在SGA中的3个位置上。

* 默认池(default pool)：所有来自段中的块一般都在这个池中缓存。这就是上面提到的较早版本中那个唯一的块缓冲区缓存。
* 保留池（keep pool):当一些被频繁访问的段放在默认池中后，它们会因为其他段对块缓冲缓存的需求而老化退出（age out)默认池，如果你希望能将这些被频繁访问的段也尽量保留在块缓冲区缓存中，按惯例应使用保留池。
* 回收池：与保留池相反，当你很随机访问一些大型的段时，如果把这些段放在默认池（或保留池）中，会导致其他常用且频繁访问的块被刷出缓冲区缓存。另外缓存这些的大型段也没有什么意义，因为等你想要再次访问这个块时，它可能已经老化退出了缓存。所以要把这种段与其他段分开，这样就不会导致真正需要留在默认池和保留池中的块老化退出缓存，这种情况按惯例应使用回收池。

实际上，这3个池以基本相同的方式管理块；即用于块缓存和老化退出的算法并没有根本性的差异。分成3个池目的是让DBA能把段区分成“热“(hot)区，“温”（warm)区和“不适合缓存”区。

​       为保证“温块“能留在缓存中，可以采用下面的某种做法：

* 将这些段分配至保留池，力图让温块在缓冲区缓存中停留得更久。
* 将“不适合缓存”段分配到回收池，并将回收池设置得很小，以便块能快速的进入缓存和离开缓存（减少内存管理开销）

从oracle9i开始，除了上述三咱外，dba还可以考虑第4种可选的缓存：DB_nK_CACHE_SIZE，增加这些缓存是为了支持一个数据库存大多种不同大小块的情况。

#### 4.2.3.1、在缓冲区缓存中管理块

为简单起见，我们这里假设只有一个默认池（由于其他池都以同样的方式管理，所以只需讨论其中一个池）

缓冲区缓存中的块实质上在一个区域上管理，但有两个不同的列表指向这些块。

* 脏(dirty)块列表，其中的块需要由数据库写入器(DBWn)写入磁盘。
* 非脏块列表

8.0及以前版本中，非脏块列表用的是一种最近最少使用（Least Recently Used,LRU)列表，所有的块按照使用的顺序列出。8i及以后的版本中，采用接触器（touch count ，也称使用计数）算法，如果你的数据库命中(hit)缓存中的某个块，则会增加与之关联的计数器的值。X$表

​       频繁使用的块会被缓存而不常用的块不会缓存太久。

#### 4.2.3.2 多种块大小

从9i开始，同一种数据库可以有多种不同的块大小，之前的数据库所有块的大小都相同，要想使用一种不同的块大小 ，必需重新建立整个数据库。现在可以有一个“默认的”块大小（最初创建数据库时使用的块大小，即system和所有temporary表空间的块大小),以及最多4种其他的块大小。每种不同的块大小都必须有其自己的缓冲区缓存。默认池，保留池和回收池只能缓存具有默认大小的块。为了在数据库中使用非默认的块大小，需要配置相应的缓冲区池来保存这些块。

示例：未配置一个16k的缓存，报错

```
SQL> create tablespace ts_16k datafile '/tmp/ts_16k.dbf'
  2  size 5m
  3  blocksize 16k;
create tablespace ts_16k datafile '/tmp/ts_16k.dbf'
*
ERROR at line 1:
ORA-29339: tablespace block size 16384 does not match configured block sizes

SQL> show parameter sga
NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
allow_group_access_to_sga	     boolean		    FALSE
lock_sga			     boolean		    FALSE
pre_page_sga			     boolean		    TRUE
sga_max_size			     big integer	    1520M
sga_min_size			     big integer	    0
sga_target			     big integer	    1520M
unified_audit_sga_queue_size	     integer		    1048576

SQL> alter system set sga_target=1024M scope=spfile;【缩小sga大小】

System altered.

SQL> alter system set db_16k_cache_size=16m scope=spfile;

System altered.

SQL> startup force;

SQL> show parameter 16k;

NAME				     TYPE		    VALUE
------------------------------------ ---------------------- ------------------------------
db_16k_cache_size		     big integer	    16M

SQL> create tablespace ts_16k datafile
  2  '/tmp/ts_16k.dbf'
  3  size 5M blocksize 16k;

Tablespace created.
```

注意：从oracle9i开始，即使数据库已经启动并且正在运行，你也能重新设置各个SGA组件的大小。如果你想要能够动态地“扩大”SGA的大小（超过初始分配的大小），不必须把SGA_MAX_SIZE参数设置为大于已分配SGA的某个值。例如，如果启动之后，你的SGA大小为800M，你想再为缓冲区缓存增加额外的200M，就必须把SGA_MAX_SIZE设置为1G或更大，以便扩展。

​     默认池、保留池和回收池对于块缓冲区缓存的精细调优来说应该已经足够了，多种块大小主要用于从一个数据库向另一个数据库传输数据，也可能用在报表/事务处理的混合系统中。

### 4.2.4 共享池

共享池(shared pool) 是SGA中最重要的内存组件这一，特别是对于性能和可扩展性来说更是如此。

共享池是缓存一些“程序”数据的地方，在解析一个查询时，角标得到的结果(representation)就缓存在那里。在完成解析整个查询的任务之前，数据库会搜索共享池，看看这个工作是否已经完成。

​        共享池的特点是有大量小的内存块（chunk)，一般为4k或更小。要记住，4K并不是一个硬性限制，可能有的内存分配会超过这个大小 ，但一般来讲，我们的目标是使用小块的内存来避免碎片问题。如果分配的内存块大小有显著的不同（有的很小，有的却很大），就可能出现碎片问题。数据库提供了DBMS_SHARED_POOL包，可能将对象牢牢的“钉”在共享池中。可以在数据库启动时将这个过程用于加载那些频繁使用的过程和包，使它们不至于老化退出。

​       想要破坏共享池机制，最容易的办法是不使用绑定变量。在第1章中已经看到，如果不使用绑定变量，可能会让系统陷入瘫痪，这有两个原因：

* 系统要花大量CPU时间解析查询
* 系统使用大量资源来管理共享池中的对象，但它们却从不被重用

从10g开始，shared_pool_size参数控制了共享池的大小；而在9i及之前的版本中，它只是共享池中贡献最大的部分。



### 4.2.5 大池

大池用于大块内存的分配，而共享池无法处理这么大的内存块

​       大池是一个回收型的内存空间，而共享池则更像是保留缓冲区池（如果对象可能会被频繁地使用，就将其缓存起来），大池中分配的内存采用的是堆管理方式，一块内存一旦被“释放”了，它就能由其他进程使用。而在共享池中，实际上并没有释放内存块的概念。

​       大池专门用于以下情况：

* 共享服务器连接，用于在SGA中分配UGA区
* 语句的并行执行，允许用来分配进程间的消息缓冲区，这些缓冲区用于协调并行查询服务器
* 备份，在某些情况下用于RMAN磁盘IO缓冲区

如果DBWR_IO_SLAVES或者PARALLEL_MAX_SERVERS参数设置为某个正值，大池会被默认设置为某个大小。如果你使用了一个需要用到大池的功能，建议手动设置大池的大小。默认机制一般并不适合你的情况。

### 4.2.6 JAVA池

从8.1.5版本中起增加了JAVA池，目的是支持在数据库中运行JAVA。参数JAVA_POOL_SIZE用于确定为所有会话的JAVA代码和数据分配多大的JAVA池内存总量

java池有多种用法，取决于数据库运行的模式。如果采用专用服务器模式，java池包括每个java类的共享部分，由每个会话使用。这些实质上是只读部分（执行向量，方法等），每个类共享部分大约4-8K。因此，采用专用服务器模式时，java池所需的总内存相当少，可以根据要用的java类的个数来确定。请注意，如果采用专用 服务器模式，每个会话的状态不会存储在SGA中，而是存储在UGA中。

如果采用共享服务器连接oracle，java池中包括以下部分：

* 每个java类的共享部分
* UGA中用于各会话状态的部分，这是从SGA中的java池分配的。UGA中余下的部分会照常在共享池中分配，或者如果配置了大池，就会在大池中分配。



### 4.2.7 流池

流池是10g开始增加的一个SGA结构。许多oracle 产品用到了流池，包括oracle goldengate,xstream,oracle streams,oracle advanced queuing和oracle data pump

流池大小通过设置streams_pool_size参数值做为流池的一个最小值，如果sga_target和streams_pool_size参数都被设置为0，则将会在共享池中使用最多10%的空间作为流池。

流池只对使用了相应功能（例如goldengate,streams等）的系统来说是重要的，在这些环境中，必须设置流池，以避免因为这些功能从共享池“窃取”10的空间。

### 4.2.8 SGA内存管理

SGA内存管理的相关参数分为两类

* 可以自动调优的SGA参数(auto-tuned SGA parameter):DB_CACHE_SIZE,SHARED_POOL_SIZE,LARGE_POOL_SIZE,JAVA_POOL_SIZE和STREAMS_POOL_SIZE。
* 需要手动调整的SGA参数（manual SGA parameter) ：LOG_BUFFER,DB_NK_CACHE_SIZE,DB_KEEP_CACHE_SIZE和DB_RECYCLE_CACHE_SIZE.

在10g及更高版本中，任何时候你都能通过查询V$SGAINFO来查看SGA的哪些组件的大小是可以调整的。



```
SQL> set linesize 1500
SQL> select * from v$SGAINFO;
```

对于SGA内存组件中那些可以自动调优的部分，有以下3种方式对它们进行管理。

* 手动SGA内存管理：即手动设置必须的池和缓存参数
* 在10g及更高版本中，使用自动SGA内存管理：即设置SGA_TARGET参数。通过设置该参数，数据库实例便能自动设置和调整SGA中的这些组件的内存大小
* 在11g及更高版本中，使用自动内存管理：即设置memory_target参数。通过设置该参数，数据库实例便能自行管理SGA和PGA的内存区域。

#### 4.2.8.1 手动SGA内存管理

若需要在一定程序上对SGA内存中可以自动调优的部分进行控制，那就把memory_target和sga_target设置为0。关闭自动内存管理和自动SGA自动管理。

注意：在9i和之前的版本中，只存在手动SGA内存管理功能，SGA_TARGET参数是不存在的，另一个参数SGA_MAX_SIZE是用来设置SGA的最大范围。

禁用自动内存管理之后，就可以手动设置相关的SGA内存参数了： DB_CACHE_SIZE,SHARED_POOL_SIZE,LARGE_POOL_SIZE,JAVA_POOL_SIZE和STREAMS_POOL_SIZE。这些参数都有自己的默认值，如果没有明确的设置它们，Oracle将使用它们的默认值。例如，DB_CACHE_SIZE的默认值为48M或4M乘以CPU个数（取这两者中较大的那个值）

有一点请注意，在11g及以上版本中，即使已经明确地关闭了自动内存管理（memory_target和sga_target设置为0)，Oracle仍会做一些自动的内存重分配动作，即从数据库的缓冲区缓存分出内存给共享池

```
[oracle@odoo dbs]$ cat initPOS.ora
POS.__data_transfer_cache_size=0
POS.__db_cache_size=301989888
POS.__inmemory_ext_roarea=0
POS.__inmemory_ext_rwarea=0
POS.__java_pool_size=16777216
POS.__large_pool_size=16777216
POS.__oracle_base='/u01/app/oracle'#ORACLE_BASE set from environment
POS.__pga_aggregate_target=268435456
POS.__sga_target=368435456
POS.__shared_io_pool_size=33554432
POS.__shared_pool_size=285212672
POS.__streams_pool_size=0
POS.__unified_pga_pool_size=0
*.audit_file_dest='/u01/app/oracle/admin/POS/adump'
*.audit_trail='db'
*.compatible='19.0.0'
*.control_files='/u01/app/oracle/oradata/POS/control01.ctl','/u01/app/oracle/recovery_area/POS/control02.ctl'
*.db_block_size=8192
*.db_name='POS'
*.db_recovery_file_dest='/u01/app/oracle/recovery_area'
*.db_recovery_file_dest_size=8256m
*.diagnostic_dest='/u01/app/oracle'
*.dispatchers='(PROTOCOL=TCP) (SERVICE=POSXDB)'
*.memory_target=0
*.nls_language='AMERICAN'
*.nls_territory='AMERICA'
*.open_cursors=300
*.pga_aggregate_target=268435456#20200620
*.processes=300
*.remote_login_passwordfile='EXCLUSIVE'
*.resource_limit=FALSE
*.sga_target=0
*.undo_tablespace='UNDOTBS1'

SQL> startup pfile='/u01/app/oracle/product/19.3.0/db_1/dbs/initPOS.ora'
ORACLE instance started.

SQL> set linesize 1500
SQL> select * from v$sgainfo;

NAME								      BYTES RESIZE     CON_ID
---------------------------------------------------------------- ---------- ------ ----------
Fixed SGA Size							    8895480 No		    0
Redo Buffers							    3686400 No		    0
Buffer Cache Size						   50331648 Yes 	    0
In-Memory Area Size							  0 No		    0
Shared Pool Size						  213909504 Yes 	    0
Large Pool Size 							  0 Yes 	    0
Java Pool Size								  0 Yes 	    0
Streams Pool Size							  0 Yes 	    0
Shared IO Pool Size						    4194304 Yes 	    0
Data Transfer Cache Size						  0 Yes 	    0
Granule Size							    4194304 No		    0

NAME								      BYTES RESIZE     CON_ID
---------------------------------------------------------------- ---------- ------ ----------
Maximum SGA Size						  276823032 No		    0
Startup overhead in Shared Pool 				  163753672 No		    0
Free SGA Memory Available						  0		    0
```

查看SGA上自动调整内存大小的动作视图，在所有的SGA自动调整动作，视图中OPER_MODE列都交它们标识为DEFERRED(推迟)模式或IMMEDIATE（立即）模式。当使用动手SGA内存管理时，SGA自动调整功能对所有被标识为DEFERRED的请求是禁用的，但对IMMEDIATE模式的请求仍是可用的。因此即使使用手动SGA内存管理，仍可以看到DB_CACHE_SIZE的操作信息

```
SQL> select * from V$MEMORY_RESIZE_OPS;
DEFAULT buffer cache   SHRINK  IMMEDIATE db_cache_size                                                                   50331648    46137344   46137344 COMPLETE  2020/6/30 2 2020/6/30 2          0
20 rows selected
```

创建DBMS_SHARED_POOL包用来将一些对象“钉”在共享池中

```
SQL> @?/rdbms/admin/dbmspool
SQL> grant execute on dbms_shared_pool to eoda;【给用户授权包执行权限】
```

#### 4.2.8.2 自动SGA内存管理

​     自动SGA内存管理模式下，参数SGA_TARGET做为首要参数来控制各个可自动调优组件的总大小，并且该参数可在数据库启动并运行的状态下动态调整（最大可以达到SGA_MAX_SIZE设定的大小）。SGA_MAX_SIZE的默认值等于SGA_TARGET的值，因此如果你打算之后在数据库运行时增大SGA_TARGET，那必须在数据库实例启动之前，将SGA_MAX_SIZE的值设置大于SGA_TARGET.数据库将使用 SGA_TARGET的值减掉那些需要手工调整组件大小(例如DB_KEEP_CACHE_SIZE，DB_RECYCLE_CACHE_SIZE等)，再用这个结果值来设置默认缓冲池，共享池，大池和JAVA池的内存。在数据库运行期间，还会根据需要动态的调整这4个内存区域。当共享池内存不够用时，数据库会选择把缓冲区缓存缩小几M（1个颗粒大小），并把这些内存加到共享池中。

注意：使用自动SGA内存管理，STATISTICS_LEVEL参数必须被设置为TYPICAL（默认值）或者ALL。如果统计信息收集功能没有启用，数据库就没有相关历史记录来判断各个组件所需的内存大小。 

​            经过一段时间运行后，实例中内存需求被确定下来，SGA各个组件将调整到合适大小。数据库会记录以下4个组件（缓冲池，共享池，大池和JAVA池）的正确大小，以免每次停机重启都要重新再确定一遍。这是通过四个双下划线开头的参数来实现的：__db_cache_size，____java_pool_size，__large_pool_size和__shared_pool_size。当使用正常（normal)模式关闭或立即(immediate)模式关闭数据库时，这4个参数会被记录到存储参数文件（SPFILE)中，并在下次启动时用这些参数做为默认值来设置对应组件的内存区域。

注意：上面说到的这个保存各个池推荐大小的特性，只在使用存储参数文件（SPFILE)时才生产。

​       此外，如果你想为5个区域(可自动调优的5个组件)之一设置一个最小值，可以在设置SGA_TARGET的前提下设置该区域对应的参数。数据库实例将会使用你设置的参数做为这个区域大小的下限，或者是该区域可能的最小值。



#### 4.2.8.3 自动内存管理

对于10g和自动SGA内存管理，DBA只需要设置两个主要的内存设置:PGA_AGGREGATE_TARGET和SGA_TARGET。如前所述，数据库会在PGA和SGA中自动分配和重新分配内存块。在11g中，DBA现在只需设置一个内存参数MEMORY_TARGET。这个参数表示SGA和PGA分配能达到的总内存量的上限（尽量不超出，但要记住，PGA在某些情况下不可控）

​        与自动SGA内存管理一样，DBA可以设置SGA_TARGET和PGA_AGGREGATE_TARGET，做为SGA和PGA区域大小的下界， 可以通过设置SGA中每个池对应的参数，来设定各个池的下界。如果使用了存储参数文件，数据库会记住各个池以及SGA和PGA的最优设置。



# 第5章 Oracle进程

 Oracle实例主要有3类进程

* 服务器进程：这些进程根据客户端的请求来完成工作。之前我们已经对专用服务器和共享服务器有了一定的了解，它们就是服务器进程
* 后台进程：这些进程随数据库启动而启动，用于完成各种维护任务
* 从属进程：这些进程类似于后台进程，它们代表后台进程或服务器进程执行一些额外的工作

## 5.1 服务器进程

专用服务器(dedicated server)连接：采用专用服务器连接时，会在服务器上得到一个针对这个连接的专用进程。这时，数据库连接与服务器进程（线程）之间是一一对应的

共享服务器（shared server)连接：采用共享服务器连接时，多个会话可以共享一个服务器进程池，其中的进程由Oracle实例生成和管理。你所连接的是一个数据库调试器（dispatcher),而不是特意为该连接创建的专用服务器进程。

### 5.1.1 专用服务器连接

Oracle采用Oracle Net来支持客户端/服务器处理（即使在一个n层体系结构中也会“潜伏”着客户端/服务器程序。即使客户端和服务器在同一台机器上，也会采用这种双进程（也称双任务）体系结构，有如下两个好外：

* 远程执行：很显示，客户端应用和数据库可以在不同的机器上运行
* 地址空间隔离(address space isolation)：服务器进程是可以读写SGA的，如果客户端进程和服务器进程物理地链接在一起，客户端进程中一个错误的指针就会轻易破坏SGA的数据结构。

```
SQL> set linesize 2500
SQL> select a.spid dedicated_server,b.process clientpid from v$process a ,v$session b where a.addr=b.paddr and
  2  b.sid=sys_context('userenv','sid');

DEDICATED_SERVER				 CLIENTPID
------------------------------------------------ ------------------------------------------------
9248						 9079
SQL> !/bin/ps -fp 9248 9079
UID        PID  PPID  C STIME TTY      STAT   TIME CMD
oracle    9079  8929  0 11:44 pts/0    Sl+    0:00 sqlplus   as sysdba
oracle    9248  9079  2 11:45 ?        Ss     0:03 oraclePOS (DESCRIPTION=(LOCAL=YES)(ADDRESS=(PROTOCOL=beq)))
```

### 5.1.2 共享服务器连接

共享服务器连接要求必须使用Oracle Net，即使客户端和服务器都在同一台机器上也不例外。如果不使用Oracle TNS监听器，就无法使用共享服务器。如前所述，客户端应用会连接到Oracle  TNS监听器，并重定向或转交给一个调度器程序。调度器充当了客户端应用和共享服务器进程之间的管道。

​         共享服务器连接模式下，对客户端而言，在连接到数据库之后，分不清到底是专用服务器连接还是共享服务器连接。看上去都一样，只是在数据库级别二者才会有显著的区别。

### 5.1.3 数据库常驻连接池

数据库常驻连接池(DRCP)是连接数据库并建立会话的一种可选方法。有些应用接口自身不支持高效连接池（如PHP），DRCP就是为这种应用接口设计的一种更为高效的连接方法。

​          DRCP不仅具备共享服务器模式中的进程池的功能，同时还具有专用服务器模式中的高性能的特性。



### 5.1.4 连接与会话

在Oracle中，连接只是客户端进程和数据库实例之间的一个物理链路，最常见的就是网络连接。

一个连接上可以有0个或多个会话，这说明可以有连接而无相应会话。另外一个会话可以有连接也可以没有连接。例如使用高级Oracle Net（如连接池）时，客户端可以删除一个物理连接，而会话依然保留（但是会话会空闲）。当客户端需要在这个会话上执行某个操作时，它会重新建立物理连接。

连接(connection)：连接是从客户端到Oracle数据库实例的一条物理路径。

会话（session)：会话是数据库实例中存在的一个逻辑实体

同一个连接两个会话示例(11g演示成功，19c上演示不成功)

```
D200@topprod> select username,sid,serial#,server,paddr,status from v$session where username=USER;

USERNAME                              SID    SERIAL# SERVER    PADDR            STATUS
------------------------------ ---------- ---------- --------- ---------------- --------
D200                                   30      13071 DEDICATED 00000000F146C218 ACTIVE

D200@topprod> set autotrace on statistics;

D200@topprod> select username,sid,serial#,server,paddr,status from v$session where username=USER;

USERNAME                              SID    SERIAL# SERVER    PADDR            STATUS
------------------------------ ---------- ---------- --------- ---------------- --------
D200                                   30      13071 DEDICATED 00000000F146C218 ACTIVE
D200                                   32      42407 DEDICATED 00000000F146C218 INACTIVE

此处parrd相同，即表示同一个物理连接地址
当关闭autotrace功能时，之前的连接即关闭了，只剩下一条纪录
D200@topprod> set autotrace off;
D200@topprod> select username,sid,serial#,server,paddr,status from v$session where username=USER;

USERNAME                              SID    SERIAL# SERVER    PADDR            STATUS
------------------------------ ---------- ---------- --------- ---------------- --------
D200                                   30      13071 DEDICATED 00000000F146C218 ACTIVE

执行disconnect命令时，会话会终止，但连接还存在，即逻辑连接已终止，但物理连接还存在【通过内存地址查询v$process视图】
D200@topprod> disconnect
SYS@topprod> select * from v$session where username='D200';

no rows selected

SYS@topprod> select username,program from v$process where addr=hextoraw('00000000F146C218');

USERNAME        PROGRAM
--------------- ------------------------------------------------
oracle          oracle@Oracle-TEST
```

### 5.1.5 专用服务器、共享服务器和数据库常驻连接池

#### 5.1.5.1 什么时候使用专用服务器

在非OLTP环境中，也就是可能有长时间运行事务的情况下，应该只考虑使用这种模式。专用服务器也是Oracle的推荐配置，它能很好的扩展。只要服务器有足够的硬件资源(CPU和内存)来应对系统所需的专用服务器进程个数，专用服务器基于可能用于数千条并发连接。

#### 5.1.5.2 什么时候使用共享服务器

共享服务器的首要原则：要确保事务的持续时间尽量短。事务可以频繁的执行，但必须在短时间内执行完（这正是OLTP系统的特点）。在极端情况下，如果所有共享服务器进程都很忙，除了少数几个独占着共享服务器的幸运者以外，对其他用户来说，系统就好像挂了。

​       在使用共享服务器时，还会观察到另一个现象，人为死锁(artificial deadlock)

​       由于上述原因，共享服务器只适用于OLTP系统。这种系统特点是事务短而且频繁。在一个OLTP中，事务以毫秒为单位执行，任何事务的执行都会在1秒以内的片刻时间内完成。

​         有时使用共享服务器是因为别无选择。许多高级连接特性都要求使用共享服务器。如 Oracle Net连接池，集中式数据库链（database link concentration，适用于大量的会话通过数据库链访问远程数据库）。

​        注意：如果你的应用中已经使用了一个连接池特性（例如，你在使用J2EE连接池)，耐用适当地确定了连接池的大小，那么再使用共享服务器只会成为性能杀手，导致性能下降。因为你已经确定了连接池的大小，以适应任何时间点可能的并发连接数，所有你会希望这些连接都是直接的专用服务器连接。否则，你只是在同一个连接池功能连接到另一个连接池功能而已。

#### 5.1.4.3 共享服务器的潜在好处

* 减少操作系统进程/线程数
* 人为的限制并发度
* 减少系统所需内存（但在自动PGA下，内存减少度很有限）

#### 5.1.4.4 数据库常驻连接池(DRCP)

DRCP非常适合用于客户端应用本身的API没有提供高效连接池的情况。



### 5.1.6 专用/共享服务器小结

除非你的系统负载过重，或者需要为某个特定的功能使用共享服务器，否则专用服务器可能最适合你。专用服务器设置起来很简单（实际上，并不需要设置什么），而且调优也更容易。

如果你面对的用户群很大，而且你知道将要使用共享服务器模式，那么强烈建议你在共享服务器模式下开发和测试你的应用。

## 5.2 后台进程

Oracle实例由两个部分组成：SGA和一组后台进程。

```
SYS@POS> select paddr,name,description from v$bgprocess;【PADDR列不为00的都是系统上现在配置和运行的进程(线程)】
PADDR		 NAME	    DESCRIPTION
---------------- ---------- --------------------------------------------------------------------------------------------------------------------------------
00		 ABMR	    Auto BMR Background Process
00		 ACFS	    ACFS CSS
0000000070B05BF8 PMON	    process cleanup
0000000070B07158 CLMN	    process cleanup
0000000070B086B8 PSP0	    process spawner 0
```

后台进程分为两类：一种是特定任务的进程(如前所述)，另一种是能够执行各种其他任务的进程（如工具进程）。

### 5.2.1 特定任务后台进程

```
SYS@POS> startup pfile='/tmp/pfile' mount;
ORACLE instance started.

Total System Global Area  524285856 bytes
Fixed Size		    8898464 bytes
Variable Size		  352321536 bytes
Database Buffers	  159383552 bytes
Redo Buffers		    3682304 bytes
Database mounted.
SYS@POS> select paddr,name,description from v$bgprocess where paddr<>'00' order by paddr desc;

PADDR		 NAME	    DESCRIPTION
---------------- ---------- --------------------------------------------------------------------------------------------------------------------------------
0000000066713758 M000	    MMON slave class 1
00000000667121F8 TMON	    Transport Monitor
0000000066710C98 MMNL	    Manageability Monitor Process 2
000000006670F738 MMON	    Manageability Monitor Process
000000006670E1D8 FENC	    IOServer fence monitor
000000006670CC78 PXMN	    PX Monitor
000000006670B718 W001	    space management slave pool
000000006670A1B8 LREG	    Listener Registration
0000000066708C58 W000	    space management slave pool
00000000667076F8 RECO	    distributed recovery
0000000066706198 SMCO	    Space Manager Process
0000000066704C38 SMON	    System Monitor Process
00000000667036D8 CKPT	    checkpoint
0000000066702178 LGWR	    Redo etc.
0000000066700C18 DBW0	    db writer process 0
00000000666FF6B8 DIA0	    diagnosibility process 0
00000000666FE158 PMAN	    process manager
00000000666FCBF8 SVCB	    services background monitor
00000000666FB698 VKRM	    Virtual sKeduler for Resource Manager
00000000666FA138 SCMN
00000000666F8BD8 OFSD	    Oracle File Server BG
00000000666F7678 DIAG	    diagnosibility process
00000000666F6118 SCMN
00000000666F4BB8 GEN1	    generic1
00000000666F3658 MMAN	    Memory Manager
00000000666F20F8 DBRM	    DataBase Resource Manager
00000000666F0B98 GEN0	    generic0
00000000666EF638 VKTM	    Virtual Keeper of TiMe process
00000000666EE0D8 PSP0	    process spawner 0
00000000666ECB78 CLMN	    process cleanup
00000000666EB618 PMON	    process cleanup

31 rows selected.
```

#### 5.2.1.1 PMON：进程监视器

负责在连接出现异常中止后进行清理工作。例如，一个专用服务器“失败”或者出于某种原因被结束掉，就要由PMON进程负责善后（恢复或撤销工作），并释放资源，PMON会回滚未提交的工作，释放锁，并释放之前为失败进程分配的SGA资源。

注意：12c之前，PMON还负责处理注册监听的任务。从12c开始，改由专门的监听注册后台进程(LREG)来注册实例和服务器监听器。

#### 5.2.1.2 LREG：监听注册进程

负责将数据库实例和服务注册到监听器中。数据库实例启动后，如果监听器处于运行状态，LREG会与监听器进行通信，并将相关的参数传递给监听器（例如服务器名以及实例的负载指标），如果监听器没有启动，LREG将会定期（通常是每60秒）去尝试联系监听器，以便将自己注册到监听器中。你也可以使用alter syster register命令让LREG立即尝试在监听器上注册服务，在高可用环境中很有用。

#### 5.2.1.3 SMON：系统监听器

SMON进程用来做所有"系统级"的任务。之前的PMON所对应的是各个进程，而SMON则是从系统级的视角出发，成为了数据库上的垃圾收集器。

* 清理临时表空间：原先清理临时表空间这样的杂事都由我们自己动手完成，随着引入了“真正”的临时表空间的特性，这个负担已减轻，但并不是说完全不需要清理了。

* 合并空闲表空间：如果你在使用字典管理的表空间，SMON会负责取得表空间中相互连续的空闲区段，并把他们合并为一个更大的空闲区段。

* 针对原来不可用的文件恢复活动的事务

* 执行RAC中失败节点的实例恢复

* 清理OBJ$：OBJ$是一个底层的数据字典表，数据库中几乎每个对象(表，索引，触发器，视图等)都在其中对应一个条目。不存在或被删除的这些对象，要由SMON来清理。

* 管理撤销段：SMON会负责实施撤销（undo)段的自动上下线(onlining 和offlining)，以及收缩撤销段

* 回滚段离线：当使用手动的回滚段管理时（这不是推荐的用法，你还是应该使用自动撤销管理方式）

  除上述外外，还会做一些其他事。随着时间的推移，SMON进程可能会累积使用大量的CPU时间，这是正常的，SMON会定期醒来（或者被其他后台进程唤醒）来执行这些维护工作。

#### 5.2.1.4 RECO:分布式数据库恢复

非常核心的任务是：由于两阶段提交（2PC）期间的崩溃或连接丢失等原因，有些事务可能会保持在准备状态，这个进程就是要恢复这些事务

#### 5.2.1.5 CKPT：检查点进程

它并不像它的名字所写的那样是用来建立检查点，实施检查点主要是DBWn进程的工作。CKPT仅仅是协助实际运行检查点的进程，来更新数据文件的文件头。

​        原先，用检查点信息去更新数据文件头的工作是属于LGWR进程的；不过，一段时间后，当数据文件数量随着数据库大小的增加而增加后，对LGWR来说，这个额外的工作负担就变得太重了。如果LGWR必须更新数十个，数百个甚至数千个文件时，等待提交事务的会话就可能必须等待很长时间。有了CKPT，这个任务就不用LGWR操作了

#### 5.2.1.6 DBWn：数据块写入器

它负责将脏块写入磁盘的后台进程。若DBWn写出块的速度不够块，不能很快释放缓冲区，就会看到Free Buffer waits 和Write Complete Waits这两个等待事件的数量和等待时间开始增加，我们可以配置多个DBWn进程，实际上11g可以配置36个，12c则多达100个

```
EODA@POS> select name,description from v$bgprocess where description like 'db writer process%';

NAME	   DESCRIPTION
---------- --------------------------------------------------------------------------------------------------------------------------------
BW36	   db writer process 36
DBWz	   db writer process 35 (z)
DBW0	   db writer process 0

100 rows selected.
```

DBWn会做大量的离散写(scattered write)，当你执行一个更新时，你所修改的索引的块会分散存储在磁盘上各个不同的位置，同时数据块也会随机分布在磁盘上。而LGWR则不同，它会在重做日志中进行大量的顺序写（sequential write)，这是一个很重要的区别，也是oracle在有了DBWn进程之外，还要有重做日志和LGWR进程的原因之一。离散写比顺序写慢的多。通过在SGA中缓存脏块，并由LGWR进程完成大规模顺序写并重建这些缓冲区，这样可以提升性能。通过这种机制，DBWn去完成“慢”任务，而LGWR在用户等待时完成它的“快”任务，这样我们不能得到更好的整体性能。从技术上讲，既写日志又写数据文件这样的过程会使数据库执行更多不必要的IO，因为在理论上，如果数据库能在提交事务期间将已修改的块物理地写出到磁盘，那就不需要写在线重做日志文件了。但实际上这是不可行的，LGWR还是会把每个事务的重做信息写至在线重做日志，DBWn则在后台将数据块刷新输出到磁盘。

#### 5.2.1.7 LGWR：日志写入器

LGWR进程负责将SGA中重做日志缓冲区的内容刷新输出到磁盘。满足以下条件之一时，就会做这个工作：

* 每过3秒
* 一个提交或回滚发起时
* LGWR被告知进行日志文件切换时
* 重做日志缓冲区1/3满，或者已经包含1M的缓冲数据。

与向文件的各个部分执行离散写相比，使用顺序写文件进行大批量写操作会有更高的效率。这也是使用LGWR和重做日志的主要原因。通过使用顺序IO，只把有变化的字节写出所带来的效益起过了IO本身的开销。相反，如果oracle在提交时直接将数据库块写至磁盘，就需要整块整块的执行大量离散IO，这比起让LGWR顺序地只写出有修改的部分来说就要慢得多了。

注意：从12c开始，多处理器的机器上开始使用新增的日志写入工人进程 log writer worker LG0),以提高写在线重做日志文件的性能。

#### 5.2.1.8 ARCn：归档进程

​           ARCn进程的任务是：当LGWR将一个在线重做日志文件填满时，就将其复制到另一个位置。此后这些归档的重做日志文件可以用于完成介质恢复。在线重做日志用于在出现掉电（实例终止）时“修正”数据文件，而归档重做日志则是在出现硬盘故障时用于“修正”数据文件。如果丢失了包含数据谁的system01.dbf的磁盘，我们可以去找上一周的备份，从备份中恢复该文件的备份，之后要求数据库去应用自这次备份这后生成的所有归档和在线重做日志。这样不能使这个数据文件与数据库中的其他数据文件同步，我们就可以继续使用而没有丢失任何数据。

​            ARCn通常将在线重做日志文件复制到其他至少两个位置（冗余正是不丢失数据的关键所在）。这些位置可以是本地机器的磁盘，而更合适的方式是，至少有一台位置在另一台机器上，以应付灾难性的失败。在许多情况下，归档重做日志地由另外某个进程复制到一个三级存储设备上，如磁带。也可以将这些归档重做做日志文件发送到另一台机器上，并应用于“备用数据库”（standby database)，这也是O提供的一个故障转移选项。

#### 5.2.1.9 诊断进程

​      在之前的版本中DIAG进程(diagnosability process)专用于RAC环境。从11g开始，利用ADR(高级诊断库，advanced diagonstic repository)，它会负责监视实例的整体状况，而且会捕获处理实例失败时所需的信息。这既适用于单个实例配置，也适用于多实例的RAC配置。

#### 5.2.1.10 FBDA：闪回数归档进程

这个进程是 11gR1新增的。这是新增闪回数据归档功能的重要组成部分。闪回数据归档功能是指能够闪回查询(as of 查询)很久以前的数据。这种长期历史查询功能是通过维护行的历史变化记录，即记录一个表中的每一行数据的变化来实现的。这个历史就是由后台FBDA进程维护。这个进程在事务提交之后就立即工作。FBDA进程会读该事务生成的undo，并回滚事务作出的改变。然后将回滚后的这些行（原来的值）记录到闪回数据归档中。

#### 5.2.1.11  DBRM：数据库资源管理器进程

DBRM进程（database resource manager process)会去实施那些为一个数据库实例配置的资源计划。它会设置指定的资源计划，执行相关的各种操作来实施/实现这些资源计划。资源管理器允许数据库管理员对数据库实例所用的资源，应用访问数据库所用的资源或者单个用户访问数据库所用的资源进行细粒度的控制。

#### 5.2.1.12 GEN0：通过任务执行进程

(general task execution process)为数据库提供了一个执行通用任务的进程。这个进程的主要目标是分担进程中某些可能造成进程阻塞的处理过程（这些处理过程会导致一个进程的停止），并将它们放在后台中完成。例如,如果主ASM进程需要完成某个阻塞文件的操作，而且这个操作是可以在后台被安全地完成的（就是说这个操作完成之前ASM仍可以安全地继续进行处理），在这种情况下，ASM进程就可以请求GEN0进程来完成这个操作，并让GEN0在完成任务时给出通知。本质上讲，这类似于后面要介绍的从属进程。

#### 5.2.1.13 其他常见的特定任务进程

前面的进程都是必不可少的，如果运行一个O实例，就肯定会有这些进程。下面的进程是使用ASM的数据库实例所特有的

* 自动存储管理后台(automatic storage management background,ASMB)进程：在使用了ASM的数据库实例上运行。它负责与管理存储的ASM实例通信，向ASM实例提供更新的统计信息，并向ASM实例提供心跳信息，以便让ASM实例知道它还活着，而且仍在运行。
* 重新平衡(ReBALance,RBAL)进程：RBAL进程也在使用了ASM的数据库实例中运行。在向ASM增加或移除磁盘时，RBAL进程负责处理重新平衡请求（即重新分布负载的请求。

以下进程出现在RAC实例中。RAC有两个作用：

* 高可用性
* 扩展性：可水平扩展

以下进程是RAC所特有的进程

* 锁监视器(Lock monitor,LMON)进程：监视倉中所有实例，检测是否有实例失败。这有利于恢复失败实例持有的全局锁。它还负责在实例离开或加入集群时重新配置锁和其他资源（实例失败时会离开集群，恢复为在线时又会加入集群；或者可能有新实例地加入到集群中）
* 锁管理器守护（Lock manager daemon,LMD)进程：LMD进程为全局缓存服务(global cache service,保持块缓冲区在实例间一致)处理锁管理器服务请求。它主要作为代理向一个队列发出资源请求，这个队列由LMSn进程处理。LMD会处理全局死锁的检测/解析，并监视全局环境中锁超时。在12c中，还存在LMD0产生的从属进程LDDn来协助处理以上工作。
* 锁管理器服务器(Lock manager server,LMSn)进程：O集群实例都能以读写方式访问同一组数据库文件，为了达到这个目的，各个实例的SGA块缓冲区缓存相互之间必须保持一致，这也是 LMSn进程的主要目标之一。利用此进程，可以在集群的高速网络连接上通过非常快速的缓存到缓存交换来完成数据交换。每个实例可以有多达10个LMSn进程。

* 锁(Lock,LCK0)进程：这个进程的功能与前面所述的LMD进程非常相似，但是它是负责处理除了数据库块缓冲区以外的所有全局资源的请求。

以下是大多数单实例或RAC实例的实例的常见后台进程：

* 进程生成器(PSP0)进程：这个进程负责生成（启动/创建)各个后台进程，为O实例创建新进程/线程。它会在实例启动时完成它的大部分工作。
* 虚拟时间管理器（VKTM）进程：为O实例实现一个一致的，细粒度的时钟。它负责提供时钟时间（人可读的时间），另外还提供一个分辩率极高的计时器（不一定基于时钟时间建立，更多是一个“滴答”计时装置，每经过很小的时间单位就递增一次），用于度量时段和间隔。
* 资源管理器的虚拟调度器(VKRM)进程：资源管理器的调度器，它以当前资源管理计划来控制CPU以及进程的调度
* 空间管理协调器（SMCO）进程：这个进程是可管理性基础设置（manageability infrastructure)的一部分。它会协调数据库的主动空间管理特性，如发现空间可以回的进程 和具体完成回收的进程。

### 5.2.2 工具后台进程

 这些后台进程全都是可选的，可以根据你的需要来选用。它们提供了一些工具，不过这些工具并不是每天运行数据库所必需的，除非你自己要使用（如作业队列），或者你要利用这些工具的特性（如10新增的诊断功能)

完成以下配置之后，再查看有哪些进程：

* 配置作业队列。CJQ0进程是作业队列协调器(job queue coordinator)
* 配置了高级队列(AQ)，从Qnnn(AQ队列进程，AQ queue process) 和QMNC(AQ监视器进程，AQ monitore process)可以看出
* 启动自动内存管理，由内存管理器(memory manager,MMAN)进程可以看出
* 启用了可管理/可诊断(manageablility/diagnostic) 特性，由可管理性监视器(manageablility monitore,MMON)和可管理性监视器灯(manageablility monitor light,MMNL)进程可以看出。

## 5.3 从属进程

### 5.3.1 IO从属进程

它用于在不支持异常IO的系统或设备上模拟异步IO。

IO从属进程在O中有两个用途。DBWn和LGWR可以利用IO从属进程来模拟异步IO，另外RMAN在写磁带时也可能利用IO从属进程。

有两个参数控制着IO从属进程的使用

backup_tape_io_slaves：这个参数指定RMAN是否使用IO从属进程将数据备份、复制或恢复到磁带上。

dbwr_io_slaves:这个参数指定了DBW0进程所用的IO从属进程的个数。DBW0进程及其从属进程总是将缓冲区缓存中的脏块写至磁盘。这个值默认为0，表示不使用IO从属进程。注意，如果将这个参数设置为非0的值，LGWR和ARCn也会使用其自己的IO从属进程。LGWR和ARCn最多允许有4个IO从属进程。DBWn IO从属进程的名字是I1nn，LGWR IO 从属进程的名字是I2nn。

### 5.3.2 Pnnn：并行查询执行服务器

并行查询的目标是用串行执行这个操作所需时间的几分之一来完成同样的工作。使用并行查询时，会看到名为Pnnn的进程，这些就是并行查询执行服务器。当处理一条并行语句时，服务器进程也被称为并行查询协调器(Parallel Query Coordinator) 。操作系统上的名字不会改变

​          在12c之前，并行执行服务器的默认数量为0，你可以通过将parallel_min_servers参数修改为一个非0值改变它。从12c开始，数据库实例将会自动创建一些并行服务器进程。这是因为parallel_min_servers的默认值已经被设置为了一个非0值（根据cpu_count*parallel_threads_pre_cpu乘以2得到）。例如，在我的2个CPU的机器上(cpu_count参数为2，parallel_threads_pre_cpu参数也是2，我们可以看到以下8个并行服务器正在运行。)



# 第六章 锁和闩

## 6.1 什么是锁

锁用于管理对共享资源的并发访问。除了类似表锁之外，对于存储过程等，一样会加锁。例如执行一个存储过程，过程本身会被以某种模式锁定，以允许其他用户执行这个过程，但不允许另外的用户以任何方式修改这个过程。数据库中使用锁是为了支持对共享资源进行并发访问，与此同时还要保证数据完整性和一致性。

​        不同的数据库有不同的锁机制

## 6.2 锁的问题

### 6.2.1 丢失更新

丢失更新(lost update)是一个金典的数据库问题。在没有锁的情况下，两个用户同时查询出数据进行更新，即可能出现前一次更新被后一次更新覆盖的情况，导致前一个更新丢失，称为丢失更新

### 6.2.2 悲观锁

悲观锁(prssimistic locking)这种方式在用户修改数值之前就已经开始生效了。例如，用户打算对他选择的且在屏幕上可见的某个特定行执行更新（比如通过点击某个按钮），该行就会被加上一个行锁。这个行锁会一直持续到应用程序在数据库中执行用户的修改并提交的时候。

​         悲观锁仅适用于有状态（stateful)或有连接(connected)环境。

从数据库中查询出一行，同时锁住这一行，不允许其他会话去更新它；悲观锁因此得名。我们试图更新之前就把行锁住了，因为我们很悲观，对于这一行能不能保持住未改变的状态很是怀疑。

### 6.2.3 乐观锁

第二种方法称为乐观锁(optimistic locking)[ˌɑːptɪˈmɪstɪk]，即把所有锁定的动作都延迟到即将执行更新之前才进行。换句话说，我们会修改屏幕上的信息而 不需要先锁住它。我们很乐观，认为数据不会被其他用户修改。因此，会等到最后一刻才去看我们的想法对不对。这种锁定方法在所有环境下都行得通，但采用这种方法的话，更新“失败”的可能性会加在。也就是说，用户要更新他的数据行时，却发现数据已经被修改过，那他就必须从头再来。

​        实现乐观并发控制的方法有很多种。我们已经讨论了这样的一种方法，即应用会在自身内部存储行的所有“前”映像。在后几节中，我们将看看另外两种方法。

* 使用一个特殊的列，这个列由一个数据库触发器或应用程序代码维护，用以告诉我们行记录的“版本”（version)
* 使用一个总和校验或散列，这是使用原来的数据计算得出的。

#### 1、使用版本列的乐观锁

这个方法很容易实现，如果你想保护数据库不出现丢失更新总量，就在对应的每个表上增加一列。这一列一般是number或者date/timestamp类型的列，通常通过表上的一个行触发器来维护。每次修改行时，这个触发器要负责递增number列中的值，或者更新date/timestamp列。

#### 2、使用总和校验的乐观锁

这与前面版本列方法很相似，水过它是基于数据本身来计算得出一个“虚拟的”版本列。

```
“单向散列函数取一个变长输入字符串（即数据），并把它转换为一个定长的（通常是更小的）输出串，这个输出被称为散列值（hash value)。散列值做为输入数据的一个唯一标识符（就像指纹一样）。你可以使用散列值来验证数据是否被修改。
“需要注意，单向散列函数是一种很难逆转的散列函数。将输入数据计算为散列值很容易，而通过散列值生成一个特定的数据却很难。
```

与使用版本列的做法一样，我们可以采用同样的方法使用这些散列值或总和校验。只需要简单地将从数据库读出数据时得到的散列值或总和校验值跟修改数据前得到的散列值或总和校验值进行比较。从我们读书数据之后到修改数据之前这段时间，如果有人修改了这一行的值，则散列值或总和校验值往往会大不相同。

有很多方法来计算散列值或总和校验值。在这里列出一些。

* OWA_POT_LOCK_CHECKSUM：这个方法在8i/8.1.5及更高版本中提供。其中一个方法是，给定一个字符串，返回一个16位的总和校验值。另一个方法是给定一个ROWID,会计算该行的16位校验和，并同时将这一行锁定。该方法出现冲突的可能性是65536分之一(也是出现假阳性几率最高的一种方法)

* DBMS_OBFUSCATION_TOOLKIT.MD5:这个方法在8i 8.1.7及更高版本中提供。它会计算一个128位的消息摘要。冲突的可能性是3.4028E+38分之一(非常小)

* DBMS_CRYPTO.HASH：这个方法在10g R1及更高版本中提供。它能计算一个SHA-1(安全散列算法1)或MD4/MD5消息摘要。建议使用SHA-1 算法

* DBMS_SQLHASH.GETHASH：这个方法在10g R2及更高版本中提供。它支持SHA-1,MD4和MD5的散列算法。需要由SYSDBA权限用户将执行该包的权限授予相关用户后，他们才能使用这个方法。DBMS_SQLHASH包的相关文档在Oracle Database Security Guide中

* STANDARD_HASH：这个方法在12c R1及更高版本中提供。它是一个内置的SQL函数，通过在一个表达式上使用标准的散列算法生成散列值，这些算法包括SHA1（默认），SHA256，SHA384，SHA512和MD5.它的返回值是一个RAW数据类型

* ORA_HASH：这个方法在10gR1及更高版本中提供。这是一个内建的SQL函数，取一个VARCHAR2值传为输入，还可以有另外一对输入（可选）来控制返回值。返回的值是一个数值，默认为0到4294967295中的一个数。

* ```
  注意：很多编号语言都提供了散列和总和校验函数，所以还可以考虑数据库之外的其他方法。即使如此，如果使用数据库的内置功能，还是会提高未来的可移植性。
  ```

  举例省略

### 6.2.4 乐观锁还是悲观锁

依据作者的经验，悲观锁在Oracle中工作的非常好（但在其他数据库中可能不是这样），而且与乐观锁相比，悲观锁还有很多优点。不过，它需要一个到数据库的有状态连接，如客户端/服务器连接，因为无法跨连接持有锁。正因此，在当前许多情况下，使用悲观锁是不现实的。在过去，客户端/服务器中应用上可能只有数十个或上百个用户，悲观锁是作者的不二选择。但如今，对大多数应用来说，都建议采用乐观并发控制。毕竟要在整个事务期间始终保持连接，这个代价太大了，一般无法承受。

​        乐观并发控制可用方法中，作者更倾向于使用版本列方法，增加一个时间戳列（而不只是一个number）。从长远看，这样能为我提供一个额外的更新信息。而且与散列或总和校验方法相比，计算的代价不那么昂贵。在处理Long,LONG RAW,CLOB,BLOB和其他非常大的列时，散列或总和校验方法可能会遇到一些总量，而版本列方法则没有这些问题。

​        如果必须向一个表增加乐观并发控制，而此时这个表还是被悲观锁锁定，则作者倾向于选择ORA_HASH方法

### 6.2.5 阻塞

如果一个会话持有某个资源的锁，而另一个会话在请求这个资源，就会出现阻塞(blockin)。数据库中有5个常见的DML语句可能会引起阻塞，它们是：insert,update,delete,merge,select for update。对于一个阻塞的select for update，解决方案很简单：只需增加nowait子句，它就不会阻塞了。

1、阻塞的insert

发生insert阻塞通常是因为应用允许最终用户自己生成主键/唯一列值。为避免这种情况，最容易的做法是使用一个序列或SYS_GUID()内置函数来生成主键/唯一列值。序列/SYS_GUID()是被设计用于在多用户环境中，以高并发的方式生成唯一键值。如果这两个都没法用，并且必须允许最终用户生成可能重复的键，那你可能使用以下技术，也就是使用手工锁来避免这个问题，这里的手工锁通过内置的DBMS_LOCK包来实现。【示例未演示】

2、阻塞的meger,update和delete

在一个交互式应用中，可以从数据库查询数据，允许最终用户处理这些数据，再把它“放回”到数据库中。此时如果发生update或delete阻塞，就说明你的代码中可能存在一个丢失更新问题（如果依作者看来真是这样，那代码中存在一个bug)

### 6.2.6 死锁【主表子表锁定关系】

如果有两个会话，每个会话都持有另一个会话想要的资源，此时就会出现死锁（deadlock)。例如，如果数据库中有两个表A和B，每个表中都只有一行，要做的只是打开两个会话。在会话A中更新表A，并在会话B中更新表B。现在如果想在会话B中更新表A，就会出现阻塞。因为会话A已经锁住了这一行。这不是死锁，只是阻塞而已。我还没有遇到死锁，因为会话A还有机会提交或回滚，这样会话B就能继续。

但如果我再回到会话A，并试图更新表B，这就会导致一个死锁。这时候两个会话中会有一个被“牺牲”掉，它的语句会被回滚。【在19c上实验不成功】

oracle认为死锁很少见而且不导演，所以每次死锁时它都会在服务器上创建一个跟踪文件。

根据作者经验，导致死锁的头号原因是外键未加索引（第二号原因是表上的位置索引遭到并发更新，这个内容将在第11章讨论）。在以下3种情况，修改后会对子表加一个全表锁。

* 如果更新了父表的主键（倘若遵循关系型数据库的原则，即主键应当是不可变的，这种情况很少见），由于外键上没有索引，所以子表会被锁住。
* 如果删除了父表中的一行，整个了表也会被锁住（由于外键上没有索引）。
* 如果向父表中做合并，整个子表也会锁定（没有外键的索引）。注意这一点只适用于9i和10g，11R1及更高版本不再成立。

一般来说，当满足以下条件时不需要加索引

* 不会从父表中删除行
* 不会去更新父表的唯一键/主键值。（但要当心有的工具会无意地更新主键！）
* 不会从父表连接到子表（例如DEPT到EMP的连接。

如果能满足上述全部条件，那你完全可以跳过索引，不需要对外键加索引。如果只满足以上的某个条件，就要当心不加索引的后果。

### 6.2.7 锁升级

出现锁升级(lock escalation)时，系统会降低锁的粒度。举例来说，数据库系统可以把一个表的100个行级锁变成一个表级锁。现在你用的是“能锁住全部行的一个锁”，

```
注意：oracle不会升级锁，从来不会
```

 oracle从来不会升级锁，但是这会执行锁转换(lock conversion)或锁提升(lock promotion)，这些词通常会与锁升级混淆

oracle会尽可能的尝试使用最低级别的锁(也就是，限制最小和锁)，如有必要，于把这个锁转换为一个受限更多的级别。

例如：用for update子句就会创建两个锁。一个锁放在所选的行上（这是一个排他锁；其他任何人都不能再以排他的模式锁定这一行)。另一个锁是row share table锁，放在表本身上。这个锁能防止其他会话在表上再放置一个排他锁，举例来说，这样能相应地防止这些会话改变表的结构。另一个会话可以修改这个表的任何其他行，而不会有冲突。这样，尽管表中有一行被锁住，但还是能在表上成功地执行尽可能多的命令。

### 6.3 锁类型

在oracle中主要有3类锁

* DML锁：数据操纵语言，一般指select ,insert,update,merge和delete。DMB锁机制允许并发执行数据修改。例如，DML锁可能是特定数据行上的锁，或者是锁定表中所有行的表级锁。
* DDL锁：如create和alter语句等。DDL锁可以保护对象结构定义。
* 内部锁和闩：Oracle使用这些锁来保护其内部数据结构。

例如：Oracle解析一个查询并生成优化的查询计划时，它会把库缓存闩上，将查询计划放在那里，以供其他会话使用。闩(latch)是Oracle采用的一种轻量级的低级串行设备，功能上类似于锁。不要被轻量级这个词搞糊涂或误导，你将会看到，闩是数据库中导致竞争的一个常见原因。轻量级指的是闩的实现，而不是它的影响。

### 6.3.1 DML锁

DML锁用于确保一次只有一个人能修改某一行，而且这时别人不能删除这个表。在你工作时Oracle多少会以比较透明的方式为你加这些锁。

1、TX锁

事务发起每一个修改时会得到TX锁（事务锁）。事务的发起是自动的（在Oracle中，不需要明显地开始一个事务）。TX锁会被一直持有，直至事务执行提交（COMMIT)或回滚(ROLLBACK)。TX锁被用途一种排除机制，使得其他会话可以等待这个事务完成。