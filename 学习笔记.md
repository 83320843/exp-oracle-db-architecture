# 知识扩展收集

##　涉及到的技术知识

　细粒度访问控制(find grained access control  FGAC)特性

## 常用英文收集

ASM:automatic storage management【自动存储管理】

SGA:system global area 【系统全局区】

PGA:process global area 【进程全局区】

UGA:user global area 【用户全局区】

server process:用户进程 

background process：后台进程

slave process ：从属进程

single tanent :单租户

multitanet：多租户

container/root database 容器数据库/根数据库

pluggable【ˈplʌgəbl】 database 可插拨数据库

real application clusters：真正应用数据库 RAC

instrumented[ˈɪnstrəməntɪd]：可测量，可感应的

automatic workload repository[rɪˈpɑːzətɔːri]：自动负载存储库【AWR】

active session history：活动会话历史【ASH】

automatic diagnostic [ˌdaɪəɡˈnɑːstɪk] repository：自动诊断存储库

SQL preformance analyzer[ˈænəˌlaɪzər]：SQL性能分析器



# 第一章 开发成功的oracle应用

## 1.3.3 多版本控制

读一致性与多版本控制

```
SQL> variable scn number
SQL> exec :scn := dbms_flashback.get_system_change_number;
PL/SQL procedure successfully completed
scn
---------
2571961

SQL> select count(*) from emp;

  COUNT(*)
----------
        14

SQL> delete from emp;

14 rows deleted

SQL> commit;

Commit complete

SQL> select count(*), :scn then_scn,dbms_flashback.get_system_change_number now_scn from emp 
  2  as of scn :scn;

  COUNT(*)   THEN_SCN    NOW_SCN
---------- ---------- ----------
        14    2571961    2572014
scn
---------
2571961

SQL> alter table emp enable row movement;

Table altered

SQL> flashback table emp to scn :scn;

Done
scn
---------
2571961

SQL> select cnt_now,cnt_then,
  2  :scn then_scn, dbms_flashback.get_system_change_number now_scn from (select count(*) cnt_now from emp),
  3  (select count(*) cnt_then from emp as of scn :scn)
  4  /

   CNT_NOW   CNT_THEN   THEN_SCN    NOW_SCN
---------- ---------- ---------- ----------
        14         14    2571961    2572089
scn
---------
2571961
```

session级别控制同个账户同时只能登录一个

```
SQL> create profile one_session limit sessions_per_user 1;

Profile created

SQL> alter user scott profile one_session;

User altered

SQL> alter system set resource_limit=true;

System altered
```

# 第二章 体系结构概述

## 2.1定义数据库和实例

## 2.2 连接Oracle

## 2.3 可插拔式数据库

### 2.3.1 降低资源用量

### 2.3.2 降低维护开销

# 第三章 文件

oracle文件分为以下类型：

参数文件(parameter file)：告诉Oracle在哪可以找到控制文件，应当以某种内在结构设置多大空间等。

跟踪文件(trace file)：通常是服务器进程对某种异常错误条件作出的响应时创建的诊断文件。

警告文件（alert file)：与跟踪文件类似，但是包含“期望”事件的有关信息，并且通过一个集中式文件（其中包括多个数据库事件）警告DBA

数据文件（data file)：这些文件是数据库的主要文件，其中包括表、索引和所有其他的段。

临时文件（temp file)：这些文件用于完成基于磁盘的排序和临时数据的存储。

控制文件（control file)：这些文件能告诉你数据文件、临时文件和重做日志文件在哪里，还会指出与文件状态有关的其他元数据。RMAN也会在这个文件存放数据库备份的信息。

重做日志文件（redo log file)： 这些就是事务日志。

密码文件（password file)这些文件用于认证数据库的SYS角色用户。

从Oracle10G开始，添加两类新文件，可以帮助ORACLE实现更快的备份和恢复操作。

修改跟踪文件（change-tracking file):这个文件用于ORACLE数据库建立增量备份

闪回日志文件（flashback log file)： 这些文件存储数据库块的“前映像”，它用于新增加的flashback database命令。

还会讨论

转储文件（dump file ,DMP file)：由ORACLE提供的EXP（导出）工具生成，并由IMP（导入使用），exp已被当前版本弃用，imp命令还可以继续使用，用于将老版本数据导入到新版本的数据库中。

数据泵文件（Data Pump file)：由ORACLE数据泵expdp导出（Data PumpExport)进程生成，*并由数据泵mpdp导入（Data Pump  Import)进程使用。外部表也可以创建和使用这种文件格式。

平面文件（flat file)：这种无格式文件可以在文件编辑器中查处。通常会使用这些文件赂数据库中加载数据）



只要有数据文件和重做日志文件，就算其他文件都没有，也能得到数据。若把重做日志文件弄丢失了，但丢失一部分数据。



## 3.1 参数文件（init.ora 文件）

从Oracle 9i开始采用spfile(server parameter file) 

SID（site identifier):站点标识符

### 3.1.1 什么是参数

可通过V$parameter或者show parameters查看参数设置

需要设置参数文件init.ora时必须手工编辑该文件，而spfile文件时直接在数据库中修改就可以

### 3.1.2 init.ora参数文件（PFILE【parameter file】)

默认位置：

linux : $ORACLE_HOME/dbs

windows: %ORACLE_HOME%\DATABASE

若数据库是采用init.ora启动，则alter system改变参数之后并不会直接修改init.ora文件，需要手工编辑init.ora文件

init.ora可以放到客户端，即可以通过客户端加载init.ora启动数据库，但若服务器没有此文件，则会有麻烦

### 3.1.3 服务器参数文件(SPFILE[server parameter file])

杜绝了参数文件的繁殖

再也不能在数据库之外使用文本编辑器手动的维护参数文件

#### 1、从pfile转为为spfile

SQL>show parameter spfile【当value值是空时，表示是从pfile启动的数据库】

SQL>create spfile from pfile【创建spfile】

注意：在RAC中，所有实例共享一个spfile，因此从pfile转换到spfile需要更多的手动操作。spfile可以包含所有集群节点实例的参数设置，甚至是各个实例特有的设置，但转换之前我们需要将所有的节点的参数文件合并为一个有以下格式的pfile。

```
*.cluster_database_instance=2
*.cluster_database=TRUE
*cluster_interconnects='10.10.10.0'
*.compatiable='12.1.0.0.0'
*.control_files='/u1/d1/O12C/control01.ctl','/u1/d2/O12C/control02.ctl'
*.db_name='O12C'
...
*.processes=150
*.undo_management='AUTO'
O12C1.instance_number=1
O12C2.instanc_number=2
O12C1.local_listener='LISTENER_O12C1'
O12C2.local_listener='LISTENER_O12C2'
O12C1.remote_listener='LISTENER_O12C2'
O12C2.remote_listener='LISTENER_O12C1'
O12C1.thread=1
O12C2.thread=2
O12C1.undo_tablespace='UNDOTBS1'
O12C2.undo_tablespace='UNDOTBS2'

```

集群中所有实例共享的参数设置都为*.开头。单个实例特有的参数设置（如INSTANCE_NUMBER)都以实例名(Oracle SID)为前缀。

*.db_name='O12C' 表明使用这个SPFILE所有的实例会装载一个名为O12C的数据库；

O12C1.undo_tablespace='UNDOTBS1'表明，实例O12C1会使用名为UNDOTBS1的undo表空间。

#### 2 、 设置SPFILE中的参数值

当依据SPFILE启动并运算数据库时，只能通过alter system来修改参数值, spfile文件是个二件制文件，不能用文本编辑器编辑。

原先使用init.ora参数文件时，通过alter system命令设置后，若忘记更新init.ora参数文件，或者把init.ora参数文件丢失了，就会产生问题。使用SPFILE则不会,alter system语法为：

```
alter system set parameter=value <comment='text'><deferred><scope=memery|spfile|both><sid='sid|*'><container=current|all>
```

comment='text' 是一个与此参数设置相关的可选注释。这个注释会出现在v$PARAMETER视图的UPDATE_COMMET字段中。如果将这个注释写入SPFILE，那么将来重启数据库之后也会看到这个注释。

deferred指定系统修改是否只对以后的会话生效（对当前建立的会话无效，包括执行此修改的会话）。默认情况下，alter sys命令会立即生效 ，但有些参数不能“立即“生效。只有新建立的会话才能使用这些修改之后的参数。可以通过如下命令查看哪些参数必须要deferred。

```
SQL> select name from v$parameter where issys_modifiable='DEFERRED';
```

sid='sid|*'主要用于集群环境，默认值为sid="*",SID选项可为集群中的每个实例单独地指定参数。如果不使用RAC，一般不需要指定SID=

container=current|all适用于多租户架构的数据库。如果当前连接是根容器数据库，则alter system的container=all选项可以将参数修改传递到所有的可插拔式数据库中。默认情况下，容器数据库的参数修改仅应用于自身。另需要注意的是可插拔式数据库（非根容器数据库）的参数存储于自身的数据字典中，而非SPFILE。当我们将其移动到另外一个容器时，其自身的参数设置也会随之一并转移。

comment示例

```
SQL> alter system set pga_aggregate_target=512M comment='20200620';
System altered

SQL> select value,update_comment from v$parameter where name='pga_aggregate_target';

VALUE                                                                            UPDATE_COMMENT
-------------------------------------------------------------------------------- --------------------------------------------------------------------------------
536870912                                                                        20200620
```

#### 3、取消spfile设置

```
alter system reset parametr <scope=memory|spfile|both> sid='sid|*'
```

```
SQL> alter system set sort_area_size=65536 deferred;
SQL> show parameter sort_are;
NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
sort_area_retained_size              integer     0
sort_area_size                       integer     65536

SQL> create pfile='test.ora' from spfile;【test.ora中可以看到有sort_area_size参数】

取消参数设置
SQL> alter system reset sort_area_size scope=spfile;
SQL> create pfile='test.ora' from spfile;【test.ora中没有sort_area_size参数了】
```

#### 4、从SPFILE创建PFILE

从spfile创建pfile有两种作用

4.1 创建一个“一次性”参数文件（有某些特殊的参数），用于启动数据库完成维护工作

4.2 维护修改历史，在注释中记录修改。

#### 5、修改被破坏的spfile

##### 5.1 linux下修复

若SPFILE文件损坏在linux下可以使用strings提取文件

````
$ strings $ORACLE_HOME/dbs/spfile$ORACLE_SID.ora
````

##### 5.2 windows下修复

用写字版打开，复制里面的内容粘贴到init<ORACLE_SID>.ora中，创建启用实例的PFILE。

万一SPFILE丢失了，还可以通过警告日志恢复参数文件的信息。

#### 6、可插拔式数据库

## 3.2 跟踪文件

跟踪（trace file）文件能提供调试信息

ORACLE可测量必主要表现在以下几个方面：

1,V$视图：大多V$视图包含“调试“信息。V$waitstat，v$session_event等

2,审计(audit)命令

3,资源管理器（DBMS_RESOURCE_MANAGER),这个特性允许对数据库所使用的资源（CPU，IO等）进行更精细的管理。

4，ORACLE“事件”（event),能让ORACLE生成所需的跟踪或诊断信息。

5，DBMS_TRACE：这是PL/SQL引擎中的一个工具，会全面地记录存储过程的调用树、产生的异常以及遇到的错误

6，数据库事件触发器：这些触发器（如ON SERVERERROR)允许你监控和记录觉得“意外”或非正常的情况。例如,你可以记录发生“临时空间用尽”错误时正在运行的SQL。

7、SQL_TRACE/DBMS_MONITOR:这个工具用于查看数据库执行的SQL语句、等待事件以有其他性能/行为相关的诊断信息。



10G添加了automatic workload repository[rɪˈpɑːzətɔːri]：自动负载存储库【AWR】，active session history：活动会话历史【ASH】

11G添加了automatic diagnostic [ˌdaɪəɡˈnɑːstɪk] repository：自动诊断存储库SQL preformance analyzer[ˈænəˌlaɪzər]：SQL性能分析器

12C添加了DDL日志以记录数据库中所有的DDL操作，还添加了调试日志，用于记录数据库中生产的一些异常状况。

### 3.2.1  计划内的、由用户请求所产生的跟踪文件

这类文件一般由DBMS_MONITOR来生成

#### 3.2.1.1跟踪文件位置

不论是使用DBMS_MONITOR、SQL_TRACE还是扩展的跟踪工具，ORACLE都会在数据库服务器主机的以下两个位置生成跟踪文件：

专用服务器连接，会在user_dump_dest参数指定的目录中生成跟踪文件

共享服务器连接，会在background_dump_dest参数指定的目录中生成跟踪文件

有以下几种方式查看跟踪文件位置：

```
方法一：
SQL> show parameter dump_dest
方法二：
SQL> select name,value from v$parameter where name like '%dump_dest%';
方法三：

```

 查看各种跟踪文件的位置

```
select * from v$diag_info;
```

查看ADR详细信息

```
with home
  as
  (select value home
     from v$diag_info
    where name = 'ADR Home'
  )
  select name,
         case when value <> home.home
                  then replace(value,home.home,'$home$')
                          else value
              end value
    from v$diag_info, home
/

NAME                                                             VALUE
---------------------------------------------------------------- --------------------------------------------------------------------------------
Diag Enabled                                                     TRUE
ADR Base                                                         /u01/app/oracle
ADR Home                                                         /u01/app/oracle/diag/rdbms/pos/POS
Diag Trace                                                       $home$/trace
Diag Alert                                                       $home$/alert
Diag Incident                                                    $home$/incident
Diag Cdump                                                       $home$/cdump
Health Monitor                                                   $home$/hm
Default Trace File                                               $home$/trace/POS_ora_19454.trc
Active Problem Count                                             1
Active Incident Count                                            11
ORACLE_HOME                                                      /u01/app/oracle/product/19.3.0/db_1
12 rows selected
```

Diag Trace(诊断跟踪文件)：这是11g及以下版本的跟踪文件所在位置（包括后台和用户转储目标）

Default TraceFile(默认跟踪文件)：这是当前会话的跟踪文件名。

Oracle 11g之前:共享模式的跟踪文件位于background_dump_dest,专用模式跟踪文件位于user_dump_dest

#### 3.2.1.2 命名约定

```
Default Trace File                                 $home$/trace/POS_ora_19454.trc
```

文件名第一部分为$ORACLE_SID

第二部分为ora

第三部分为专用服务器上的操作系统的进程ID，可以通过v$process视图获得

11g及之后的可以直接通过v$diag_info获得诊断位置信息，11g之前的需要通过通过视图才能获得

v$parameter：找到user_dump_dest指定的跟踪文件位置，叵初始化参数中设置了tracefile_identifier那么此参数的值也为跟踪文件名的一部分

v$process：查找操作系统上的进程ID

v$session：正确地标识其他视图中的会话信息（v$process来定位当前会话的进程ID）

v$instance：获得ORACLE_SID

```
column trace new_val TRACE format a100
select c.value || '/' || d.instance_name || '_ora_' || a.spid || '.trc' trace
    from v$process a, v$session b, v$parameter c, v$instance d
   where a.addr = b.paddr
     and b.audsid = userenv('sessionid')
     and c.name = 'user_dump_dest'
/
```

####  3.2.1.3 对跟踪文件加标记

```

SQL> alter session set tracefile_identifier='Look_for_me';
SQL> exec dbms_monitor.session_trace_enable;
$ ll *me*
-rw-r-----. 1 oracle dba 2095 Jun 21 18:15 POS_ora_23851_Look_for_me.trc
-rw-r-----. 1 oracle dba 1122 Jun 21 18:15 POS_ora_23851_Look_for_me.trm
```

### 3.2.2 针对内部错误生成的跟踪文件

执行时报的ORA-00600或另外某个内部错误而自动生成的，这种错误是用于oracle support来查看的

## 3.3 警告文件【警告日志】

警告日志是一个简单的文本文件，数据库从“出生”（创建）那一天开始就会不停写该文件，直到库“完结”（被删除）为止。在这个文件中，可以看到数据库的“编年史”，比如说在线日志文件切换，内部错误，表空间的创建，离线以及恢复为在线等等。

## 3.4 数据文件

### 3.4.1 简要回顾文件系统机制

1、格式化好的(cooked）操作系统（OS）：数据库文件就像文字处理文档一样放在文件系统中。Cooded OS文件一直是Oracle中存储数据的“最流行”的方法。随着着ASM引入，此种情况会有所改观。数据库服务器中，格式化好的文件系统通常也会缓存数据，也就是说在数据库读写磁盘时，OS会为你缓存一些信息。

2、裸分区(raw partition)：这不是文件，而是裸磁盘，不能用ls等命令查看，它们就是磁盘上的一些大扇区，没有任何文件系统。只有极少数Oracle数据库使用裸分区，裸分区管理开销大，裸分区没有缓冲，所有IO都是对存储设备直接操作，没有任何OS缓冲（对于数据库来说，这通常也是一个优点）。【Oracle11g已弃用裸分区，在12c中不再提供支持】

3、自动存储管理（automatic storage management,ASM):10g R1的新特性，ASM仅供数据库使用的文件系统，只能存储与数据库相关的信息：表，索引、备份、控制文件、参数文件、重做日志以及归档文件等。

4、集群文件系统：RAC需要使用这种文件系统，为集群中的所有节点提供一个共享文件系统。11g R2开始提供自动存储管理集群文件系统（ACFS)，此集群文件系统让cooked文件系统优点延伸到集群环境中。

​    Oracle允许数据库组成的文件可以使用上述文件中任意组合

### 3.4.2 Oracle数据库中的存储层次体系 

数据库由一个或多个表空间构成。表空间是oracle中的一个逻辑存储容器，位于存储层次体系的顶层，包括一个或多个数据文件。

#### 3.4.2.1、段

段是表空间中主要的组织结构。段就是占用存储空间的数据库对象，如表、索引及回滚段等。创建表是会创建表段，创建分区表时，为每个分区创建一个段；创建索引时，会创建一个索引段，依此类推。还存在回滚段，临时段以有聚 簇段（cluster segment等)

```
“占用存储空间的每一个对象最后都会存储在一个段中”，指一条create语句最后创建的对象可能包含0个、1个或多个段。例如：create table T(x int primary key,y clob)就会创建4个段：一个表段，一个索引段，另外还有两个clob段（一个clob段是lob索引，另一个是lob数据本身）
```

#### 3.4.2.2、区段（extent)

段本身又由一个或多个区段组成。区段是文件中一个逻辑上连续分配的空间。传统的每个段都至少有一个区段，自11g R2起oracle引入了" 延迟"段概念---当创建对象时，oracle不会立即为段分配一个区段只有当数据真正写入时，才分配。

#### 3.4.2.3、块

区段又进一步由块组成。块(block)是oracle最小的空间分配单位。通过oracle从磁盘读写的就是块。常用数据库大小有4种：2K,4K,8K,16K，也可以有非2的幂次方大小，但可能会遇到其他用户从未遇到的问题。

数据库中最多可以有6种不同的块大小：主要是用于衧一个名为“传输表空间”的功能。DBA可以利用这个功能来从一个数据库移动或复制到已经格式化好的数据库文件，把它放到另一个数据库中。

数据库还有一个默认的块大小，即执行create database 命令时初始化文件中指定的大小。system表空间总是使用这个默认块大小。

#### 3.4.2.4、表空间

表空间是一个容器，其中包含的段，每个段都只属于一个表空间。一个表空间可能有多个段，一个段的所有区段都在段所属的表空间中。段绝对不会跨越表空间边界。表空间本身可以有一个或多个 数据文件。一个区段仅会存放于一个数据文件中。不过，段可以有来自多个不同数据文件的区段。

#### 3.4.2.5 存储层次体系小结

Oracle中存储层次体系如下：

1，数据库由一个或多个表空间组成

2，表空间由一个或多个数据文件组成。这些文件可以是文件系统中的文件、裸分区，ASM管理的数据库文件，或集群文件系统上的文件。表空间包含段

3，段由一个或多个区段组成。段不能跨表空间存放，但是段中的数据可以跨文件（当然，隶属于同一个表空间）存放

4，区段是磁盘上一组逻辑连接的块。区段只能在一个表空间中，且总是在该表空间内的一个文件中

5，块是数据库中最小的分配单位，也是数据库使用的最小I/O单位

### 3.4.3 字典管理和本地管理的表空间

表空间如何管理区段：

Oracle8.1.5之前，表空间中管理区段的唯一方式是通过数据字典，相应这种表空间叫字典管理的表空间（dictionary-managed tablespace)。在此管理模式下，所有的空间管理维护操作都是在数据字典表中。数据字典更新只能是串行的，它不能并发的处理。

从8.1.5及后以的版本中，引入了本地管理表空间（locally-managed tablespace)。本地管理表空间会在每个数据文件中使用一个位图来管理区段，如果要得到一个区段，系统所做的只是在位图中将某一位设置为1；要释放一些空间，系统再把这一位设置为0.

```
如果数据库中的system是本地管理表空间，不是说这样的数据库不支持字典管理表空间，而是说我们无法在这个数据库中新建字典管理表空间。因为“可传输表空间”可将一个字典表空间的表空间“传输”到这个数据库
```

## 3.5 临时文件

oracle中的临时数据文件（temporary data file 或称临时文件 temp file)是一种特殊类型的数据文件。当内在不足时，oracle会使用它来储存一些临时数据，比如说一些比较大的排序或散列操作的中间结果，临时表中的数据库以及结果集数据等。自12c起，对临时表的操作所产生的undo也会放到临时表空间中，而在以前版本中，这部分undo是放在undo表空间中，因而会联动产生redo。永久性的表和索引永远不会存储在临时表空间中，但是临时表中的数据及其会存放在这里。